JavaScript 对网页行为进行编程
JavaScript 的核心 ECMAScript 描述了该语言的语法和基本对象；
DOM 描述了处理网页内容的方法和接口；
BOM 描述了与浏览器进行交互的方法和接口；

尽管 ECMAScript 是一个重要的标准，但它并不是 JavaScript 唯一的部分，当然，也不是唯一被标准化的部分。
实际上，一个完整的 JavaScript 实现是由以下 3 个不同部分组成的：
核心（ECMAScript）
文档对象模型（DOM）
浏览器对象模型（BOM）
ECMAScript 可以为不同种类的宿主环境提供核心的脚本编程能力，因此核心的脚本语言是与任何特定的宿主环境分开进行规定的
ECMAScript 描述了以下内容：语法，类型，语句，关键字，保留字，运算符，对象

DOM（文档对象模型）是 HTML 和 XML 的应用程序接口（API）。DOM 将把整个页面规划成由节点层级构成的文档。HTML 或 XML 页面的每个部分都是一个节点的衍生物
DOM Level 1 是 W3C 于 1998 年 10 月提出的。它由两个模块组成，即 DOM Core 和 DOM HTML。
前者提供了基于 XML 的文档的结构图，以便访问和操作文档的任意部分；后者添加了一些 HTML 专用的对象和方法，从而扩展了 DOM Core

 BOM（浏览器对象模型），可以对浏览器窗口进行访问和操作。使用 BOM，开发者可以移动窗口、改变状态栏中的文本以及执行其他与页面内容不直接相关的动作
 使 BOM 独树一帜且又常常令人怀疑的地方在于，它只是 JavaScript 的一个部分，没有任何相关的标准
 
 type 属性不是必需的。JavaScript 是 HTML 中的默认脚本语言
 脚本可被放置与 HTML 页面的 <body> 或 <head> 部分中，或兼而有之
 把脚本置于 <body> 元素的底部，可改善显示速度，因为脚本编译会拖慢显示
 <script src="myScript.js"></script> 外部脚本不能包含 <script> 标签。
 在外部文件中放置脚本有如下优势：
分离了 HTML 和代码
使 HTML 和 JavaScript 更易于阅读和维护
已缓存的 JavaScript 文件可加速页面加载

输出：
innerHTML 属性定义 HTML 内容
document.getElementById("demo").innerHTML = 5 + 6;
在 HTML 文档完全加载后使用 document.write() 将删除所有已有的 HTML
<!DOCTYPE html>
<html>
<body>
<h1>我的第一张网页</h1>
<p>我的第一个段落</p>
<script>
document.write(5 + 6);
</script>
</body>
</html> （全部显示）我的。。我的。。11
<!DOCTYPE html>
<html>
<body>
<h1>我的第一张网页</h1>
<p>我的第一个段落</p>
<button onclick="document.write(5 + 6)">试一试</button>
</body>
</html>（全部显示我的。。我的。。按钮）点击后只显示11

使用警告框来显示数据window.alert(5 + 6);
使用 console.log() 方法来显示数据。请通过 F12 来激活浏览器控制台，并在菜单中选择“控制台”

JavaScript 语句是由 web 浏览器“执行”的“指令”
JavaScript 会忽略多个空格。您可以向脚本添加空格，以增强可读性
JavaScript 关键词指的是保留的单词。保留词无法用作变量名

JavaScript 语句定义两种类型的值：混合值和变量值。混合值被称为字面量（literal）。变量值被称为变量
"Bill" + " " + "Gates"，计算为 "Bill Gates"（没引号的是变量名，+是拼接符）

JavaScript 关键词用于标识被执行的动作，var 关键词告知浏览器创建新的变量
JavaScript 中不能使用连字符。它是为减法预留的（下划线或驼峰）

单行注释以 // 开头。任何位于 // 与行末之间的文本都会被 JavaScript 忽略（不会执行）
多行注释以 /* 开头，以 */ 结尾。任何位于 /* 和 */ 之间的文本都会被 JavaScript 忽略
多行注释（注释块），注释块常用于官方声明
/*
 下面的代码会改变
 网页中
 id = "myH" 的标题
 以及 id = "myP" 的段落：
*/

JavaScript 变量必须以唯一的名称的标识。这些唯一的名称称为标识符
标识符用于命名变量（以及关键词、函数和标签），首字符必须是字母、下划线（-）或美元符号（$）
JavaScript 标识符对大小写敏感，JavaScript 中的“等于”运算符是 ==
字符串被包围在双引号或单引号中。数值不用引号。如果把数值放在引号中，会被视作文本字符串
声明之后，变量是没有值的。（技术上，它的值是 undefined。）
var carName = "porsche";
document.getElementById("demo").innerHTML = carName; 
以逗号分隔变量var person = "Bill Gates", carName = "porsche", price = 15000;

如果再次声明某个 JavaScript 变量，将不会丢它的值。
var carName = "porsche";
var carName;
在这两条语句执行后，变量 carName 的值仍然是 "porsche"

字符串也可以使用加号，但是字符串将被级联（拼接）
var x = "8" + 3 + 5; 结果是835（一个是字符就会从这个字符开始之后全部当成字符，前面的依然是算数运算）
var x = 3 + 5 + "8";结果是88
z = "Hello" + 7;结果是Hello7 对数字和字符串相加，结果将是字符串！仅一个数字，遵从下面的括号
（第一个引号前的是数值，其后的全是字符）
z = 7 + 8 + "Hello" + 7;结果是15Hello7

系数运算符（%）返回除法的余数
取幂运算符（**）将第一个操作数提升到第二个操作数的幂，x ** y 产生的结果与 Math.pow(x,y) 相同
var x = 5;
var z = x ** 2;          // 结果是 25

当多个运算拥有相同的优先级时（比如加法和减法），对它们的计算是从左向右的

JavaScript 变量能够保存多种数据类型：数值、字符串值、数组、对象等等：
var length = 7;                             // 数字
var lastName = "Gates";                      // 字符串
var cars = ["Porsche", "Volvo", "BMW"];         // 数组
var x = {firstName:"Bill", lastName:"Gates"};    // 对象 

小数点.00不会显示出来
超大或超小的数值可以用科学计数法来写
var y = 123e5;      // 12300000
var z = 123e-5;     // 0.00123
数组索引基于零，这意味着第一个项目是 [0]，第二个项目是 [1]，以此类推

JavaScript 对象用花括号来书写。对象属性是 name:value 对，由逗号分隔
var person = {firstName:"Bill", lastName:"Gates", age:62, eyeColor:"blue"};
上例中的对象（person）有四个属性：firstName、lastName、age 以及 eyeColor

typeof 运算符返回变量或表达式的类型
typeof ""                  // 返回 "string"
typeof "Bill"              // 返回 "string"
typeof 0                   // 返回 "number"
typeof 314                 // 返回 "number"
typeof 运算符对数组返回 "object"，因为在 JavaScript 中数组属于对象
JavaScript 中，没有值的变量，其值是 undefined。typeof 也返回 undefined
空值与 undefined 不是一回事。空的字符串变量既有值也有类型  var car = "";                // 值是 ""，类型是 "string"
在 JavaScript 中，null 是 "nothing"。它被看做不存在的事物。不幸的是，在 JavaScript 中，null 的数据类型是对象
var person = null;           // 值是 null，但是类型仍然是对象（object)
可以通过设置值为 null 清空对象,也可以通过设置值为 undefined 清空对象
Undefined 与 null 的值相等，但类型不相等
null === undefined            // false(类型和值都等）
null == undefined             // true（值）

原始数据：原始数据值是一种没有额外属性和方法的单一简单数据值
typeof true                // 返回 "boolean"
string，number，undefined，boolean
复杂数据：function，object
typeof 运算符把对象、数组或 null 返回 object
typeof {name:'Bill', age:62} // 返回 "object"
typeof function myFunc(){}   // 返回 "function"

() 运算符调用函数,toCelsius 引用的是函数对象，而 toCelsius() 引用的是函数结果
不使用 () 访问函数将返回函数声明而不是函数结果：function toCelsius(f) { return (5/9) * (f-32); }
document.getElementById("demo").innerHTML = toCelsius;

对象也是变量。但是对象包含很多值,（JavaScript 对象中的）名称:值对被称为属性
方法以函数定义被存储在属性中:
var person = {
  firstName: "Bill",
  lastName : "Gates",
  id       : 678,
  fullName : function() {
    return this.firstName + " " + this.lastName;
  }
};

在函数定义中，this 引用该函数的“拥有者”。
在上面的例子中，this 指的是“拥有” fullName 函数的 person 对象。换言之，this.firstName 的意思是 this 对象的 firstName 属性
能够以两种方式访问属性：objectName.propertyName或者objectName["propertyName"]
person.lastName;或者person["lastName"];
能够通过如下语法访问对象方法：objectName.methodName()； name = person.fullName();
不使用 () 访问 fullName 方法，则将返回函数定义
方法实际上是以属性值的形式存储的函数定义

如果通过关键词 "new" 来声明 JavaScript 变量，则该变量会被创建为对象：
var x = new String();        // 把 x 声明为 String 对象
var y = new Number();        // 把 y 声明为 Number 对象
var z = new Boolean();       //	把 z 声明为 Boolean 对象
请避免字符串、数值或逻辑对象。他们会增加代码的复杂性并降低执行速度

字符串长度，内建属性 length 可返回字符串的长度
var y = "中国是瓷器的故乡，因此 china 与"China（中国）"同名。"该字符串将被切为 "中国是瓷器的故乡，因此 china 与"。
避免此问题的解决方法是，使用 \ 转义字符：var x = "中国是瓷器的故乡，因此 china 与\"China（中国）\"同名。"
\b	退格键
\f	换页
\n	新行
\r	回车
\t	水平制表符
\v	垂直制表符  这六个转义字符最初设计用于控制打字机、电传打字机和传真机。它们在 HTML 中没有任何意义
\'	'	单引号
\"	"	双引号
\\	\	反斜杠 有意义就这三个

同一个字符串内不能换行：
document.getElementById("demo").innerHTML = "Hello 
Kitty!";  错误
document.getElementById("demo").innerHTML =
"Hello Kitty.";  正确
可以在字符串中换行，通过一个反斜杠即可：
document.getElementById("demo").innerHTML = "Hello \
Kitty!";
对长字符串换行的最安全做法（但是有点慢）是使用字符串加法：
document.getElementById("demo").innerHTML = "Hello" + 
"Kitty!";
不能通过反斜杠对代码行进行换行：
document.getElementById("demo").innerHTML = \ 
"Hello Kitty!"; 错误

字符串也可通过关键词 new 定义为对象：var firstName = new String("Bill")
两个对象无法比较，都会返回false：
var x = new String("Bill");             
var y = new String("Bill");
// (x ==/=== y) 为 false，因为 x 和 y 是不同的对象

通过 JavaScript，方法和属性也可用于原始值，因为在执行方法和属性时 JavaScript 将原始值视为对象
length 属性返回字符串的长度：var sln = txt.length;

indexOf() 方法返回字符串中指定文本首次出现的索引（位置）：var pos = str.indexOf("China");（C刚出现的位置）
JavaScript 从零计算位置。0 是字符串中的第一个位置，1 是第二个，2 是第三个 ...
lastIndexOf() 方法返回指定文本在字符串中最后一次出现的索引
var str = "The full name of China is the People's Republic of China.";
var pos = str.lastIndexOf("China");（最后一个China的C出现的位置）
如果未找到文本， indexOf() 和 lastIndexOf() 均返回 -1
两种方法都接受作为检索起始位置的第二个参数
lastIndexOf() 方法向后进行检索（从尾到头），这意味着：假如第二个参数是 50，则从位置 50 开始检索，直到字符串的起点，位置 50 指的是从开头算起的位置 50
var pos = str.lastIndexOf("China", 50); 前面的最后一个（也就是从后往前第一个）

indexOf() 与 search()，是相等的
search() 方法无法设置第二个开始位置参数
indexOf() 方法无法设置更强大的搜索值（正则表达式）

slice() 提取字符串的某个部分并在新字符串中返回被提取的部分
该方法设置两个参数：起始索引（开始位置），终止索引（结束位置）
如果某个参数为负，则从字符串的结尾开始计数（最后一个是-1，倒数第二个是-2，slice(-13,-1),从-2开始到-13，共12个）
slice(2，7)从3开始到7
如果省略第二个参数，则该方法将裁剪字符串的剩余部分
var res = str.slice(7);从8到最后
var res = str.slice(-13);从-13到-1
都是从左到右到最后一个字符

substring() 类似于 slice()。不同之处在于 substring() 无法接受负的索引
substr() 类似于 slice()。不同之处在于第二个参数规定被提取部分的长度，如果省略第二个参数，则该 substr() 将裁剪字符串的剩余部分
第二个参数不能为负，因为它定义的是长度
规则同slice()

replace() 方法用另一个值替换在字符串中指定的值，replace() 方法不会改变调用它的字符串。它返回的是新字符串，replace() 对大小写敏感
默认地，replace() 只替换首个匹配（从左到右）
var n = str.replace("Microsoft", "W3School"); W3School替换Microsoft
如需执行大小写不敏感的替换，请使用正则表达式 /i（大小写不敏感）：var n = str.replace(/MICROSOFT/i, "W3School");（字母对就行）
如需替换所有匹配，请使用正则表达式的 g 标志（用于全局搜索）：var n = str.replace(/Microsoft/g, "W3School");

通过 toUpperCase() 把字符串转换为大写：var text2 = text1.toUpperCase();
通过 toLowerCase() 把字符串转换为小写

concat() 连接两个或多个字符串，下面两行是等效的：
var text = "Hello" + " " + "World!";
var text = "Hello".concat(" ","World!");
所有字符串方法都会返回新字符串。它们不会修改原始字符串

trim() 方法删除字符串两端的空白符：var str = "       Hello World!        ";  alert(str.trim());
charAt() 方法返回字符串中指定下标（位置）的字符串:(从0开始，找不到返回空字符串）
var str = "HELLO WORLD";
str.charAt(0);            // 返回 H
charCodeAt() 方法返回字符串中指定索引的字符 unicode 编码：
var str = "HELLO WORLD";
str.charCodeAt(0);         // 返回 72

对字符串的属性访问 [ ]：
var str = "HELLO WORLD";
str[0];                   // 返回 H
找不到字符，[ ] 返回 undefined
它是只读的。str[0] = "A" 不会产生错误（但也不会工作！）

可以通过 split() 将字符串转换为数组：
var txt = "a,b,c,d,e";   // 字符串
txt.split(",");          // 用逗号分隔 数组元素是 a b c d e ,a[0]是
txt.split(" ");          // 用空格分隔 数组元素是 a,b,c,d,e
txt.split("|");          // 用竖线分隔
（遇到分隔符算一个元素）
var str = "a,b,c,d,e,f";
var arr = str.split(",");  数组元素是 a b c d e f ,arr[0]是a
var arr = str.split(" ");  数组元素是 a,b,c,d,e,f ,arr[0]是a,b,c,d,e,f(只有一个元素）
如果省略分隔符split()，则arr[0]等于全部
如果分隔符是 ""，则一个字符是一个数组元素

整数（不使用指数或科学计数法）会被精确到 15 位（16位的全9就会舍入成1加16个0，其他的照常显示）
小数的最大数是 17 位，但是浮点的算数并不总是 100% 精准

在所有数字运算中，JavaScript 会尝试将字符串转换为数字：
var x = "100";
var y = "10";
var z = x / y;       // z 将是 10
（加法考虑级联，其他的数字运算）

NaN - 非数值，NaN 属于 JavaScript 保留词，指示某个数不是合法数。尝试用一个非数字字符串进行除法会得到 NaN（Not a Number）：
var x = 100 / "Apple";  // x 将是 NaN（Not a Number）
不过，假如字符串包含数值，则结果将是数：var x = 100 / "10";     // x 将是 10
使用全局 JavaScript 函数 isNaN() 来确定某个值是否是数：var x = 100 / "Apple";
isNaN(x);               // 返回 true，因为 x 不是数
假如您在数学运算中使用了 NaN，则结果也将是 NaN
NaN 是数，typeof NaN 返回 number
和数字运算结果全为NaN, 和字符级联

Infinity （或 -Infinity）是 JavaScript 在计算数时超出最大可能数范围时返回的值
除以 0（零）也会生成 Infinity
var x =  2 / 0;          // x 将是 Infinity
var y = -2 / 0;          // y 将是 -Infinity
Infinity 是数：typeOf Infinity 返回 number

JavaScript 会把前缀为 0x 的数值常量解释为十六进制
绝不要用前导零写数字（比如 07）。一些 JavaScript 版本会把带有前导零的数解释为八进制
toString() 方法把数输出为十六进制、八进制或二进制
var myNumber = 128;
myNumber.toString(16);     // 返回 80
myNumber.toString(8);      // 返回 200
myNumber.toString(2);      // 返回 10000000

通过关键词 new 定义为对象：var y = new Number(123)
var x = 123;// typeof x 返回 number
var y = new Number(123);// typeof y 返回 object

toString() 以字符串返回数值。所有数字方法可用于任意类型的数字（字面量、变量或表达式）
var x = 123;
x.toString();            // 从变量 x 返回 123
(123).toString();        // 从文本 123 返回 123
(100 + 23).toString();   // 从表达式 100 + 23 返回 123

toExponential() 返回字符串值，它包含已被四舍五入并使用指数计数法的数字。参数定义小数点后的字符数，该参数是可选的。
如果您没有设置它，JavaScript 不会对数字进行舍入

