JS是解释性语言（脚本语言、动态语言），是一种编程语言（html,css不算编程语言，算计算机语言）
解释性（看一行执行一行）：不生成专门的文件  js、php等，慢，但是可以跨平台
编译性（整篇看完后再执行）：先生成文件后执行 c,c++ 快，但是移植性不好（不能跨平台） 
java是oak语言，java可以跨平台，因为生成的文件是二进制，有jvm的机器都认识

js是单线程的，执行的时候分时间片，队列是随机的，时间片足够小就像是同时进行，但还是单线程
html是标记性语言，没有分多线程单线程（执行性语言才有）

一开始是由渲染引擎执行js的，因为又要解析html又要执行js，负担太大了，因此剥离一个js引擎出来专门执行js
保留字：目前不是关键字，但是未来有可能是关键字

JavaScript 对网页行为进行编程
JavaScript 的核心 ECMAScript 描述了该语言的语法和基本对象；
DOM 描述了处理网页内容的方法和接口；
BOM 描述了与浏览器进行交互的方法和接口；

尽管 ECMAScript 是一个重要的标准，但它并不是 JavaScript 唯一的部分，当然，也不是唯一被标准化的部分。
实际上，一个完整的 JavaScript 实现是由以下 3 个不同部分组成的：
核心（ECMAScript）
文档对象模型（DOM）
浏览器对象模型（BOM）
ECMAScript 可以为不同种类的宿主环境提供核心的脚本编程能力，因此核心的脚本语言是与任何特定的宿主环境分开进行规定的
ECMAScript 描述了以下内容：语法，类型，语句，关键字，保留字，运算符，对象

DOM（文档对象模型）是 HTML 和 XML 的应用程序接口（API）。DOM 将把整个页面规划成由节点层级构成的文档。HTML 或 XML 页面的每个部分都是一个节点的衍生物
DOM Level 1 是 W3C 于 1998 年 10 月提出的。它由两个模块组成，即 DOM Core 和 DOM HTML。
前者提供了基于 XML 的文档的结构图，以便访问和操作文档的任意部分；后者添加了一些 HTML 专用的对象和方法，从而扩展了 DOM Core

 BOM（浏览器对象模型），可以对浏览器窗口进行访问和操作。使用 BOM，开发者可以移动窗口、改变状态栏中的文本以及执行其他与页面内容不直接相关的动作
 使 BOM 独树一帜且又常常令人怀疑的地方在于，它只是 JavaScript 的一个部分，没有任何相关的标准
 
 type 属性不是必需的。JavaScript 是 HTML 中的默认脚本语言
 脚本可被放置与 HTML 页面的 <body> 或 <head> 部分中，或兼而有之
 把脚本置于 <body> 元素的底部，可改善显示速度，因为脚本编译会拖慢显示
 <script src="myScript.js"></script> 外部脚本不能包含 <script> 标签。（引入外部后，在html里的script不能写东西了，否则执行的也是外部的）
 在外部文件中放置脚本有如下优势：
分离了 HTML 和代码
使 HTML 和 JavaScript 更易于阅读和维护
已缓存的 JavaScript 文件可加速页面加载

数据类型：
原始值（存在栈里）：Number,Boolean,String,undefined,null（null是空，占位符）
引用值（存在堆里）：除原始值
js中是由值确定类型
赋值内存：
1、原始值的赋变量（在栈中）是拷贝，如b = a; 先把a变量的值从栈里复制一份再给赋给b，此时b就把值写到自己对应的栈地址里
原始值是不能改变的，一旦赋值就不会变，如a = 100,先开辟地址给a，然后栈里是100，再重新给a = 200,再开了一个地址，里面是200，然后a指向它，不指向100
2、引用值的赋值：arr = [1,2]，先在栈中开辟个地址给arr变量，然后因为值是引用值，就去堆中开辟地址然后把值写入，
然后把堆相应的地址写入arr的栈地址对应的空间里，这时arr1 = arr; 则拷贝arr的栈中的值给arr1的栈，此时arr1也指向了同一个堆地址
此时arr = [1,3],就重新开辟了一个新堆地址，此时arr指向新的，不指向旧的了
调用了push，就不会重开，是在旧址里加了元素，
如果是直接赋值，值与原来不一样了，就会重新开辟空间

删东西第一次是抹去指向它的指针，东西还在，然后存东西存到同一个地址，里面原来的东西才会被重写，才算真正地删除
js是解释一行执行一行，分号就是告诉计算机一行结束了可以执行了

js错误会引发同一个块中后续代码终止，但不会影响后续代码块
（同一个html里不同的代码块（一个html可以多个script,一个script里的是一个代码块)里的代码变量是可以调用的）
语法错误一行都不会执行（会先大概扫一下，发现没有低级错误（语法错误），中文的分号等）
逻辑错误：在第一遍扫过之后，没有语法错误就会开始执行，然后执行过程中出错的就叫逻辑错误（没定义变量就打印之类的），前面的没错就会执行打印出来

输出：
innerHTML 属性定义 HTML 内容
document.getElementById("demo").innerHTML = 5 + 6;
在 HTML 文档完全加载后使用 document.write() 将删除所有已有的 HTML
<!DOCTYPE html>
<html>
<body>
<h1>我的第一张网页</h1>
<p>我的第一个段落</p>
<script>
document.write(5 + 6);
</script>
</body>
</html> （全部显示）我的。。我的。。11
<!DOCTYPE html>
<html>
<body>
<h1>我的第一张网页</h1>
<p>我的第一个段落</p>
<button onclick="document.write(5 + 6)">试一试</button>
</body>
</html>（全部显示我的。。我的。。按钮）点击后只显示11

使用警告框来显示数据window.alert(5 + 6);
使用 console.log() 方法来显示数据。请通过 F12 来激活浏览器控制台，并在菜单中选择“控制台”

JavaScript 语句是由 web 浏览器“执行”的“指令”
JavaScript 会忽略多个空格。您可以向脚本添加空格，以增强可读性
JavaScript 关键词指的是保留的单词。保留词无法用作变量名

JavaScript 语句定义两种类型的值：混合值和变量值。混合值被称为字面量（literal）。变量值被称为变量
"Bill" + " " + "Gates"，计算为 "Bill Gates"（没引号的是变量名，+是拼接符）

JavaScript 关键词用于标识被执行的动作，var 关键词告知浏览器创建新的变量
JavaScript 中不能使用连字符。它是为减法预留的（下划线或驼峰）

单行注释以 // 开头。任何位于 // 与行末之间的文本都会被 JavaScript 忽略（不会执行）
多行注释以 /* 开头，以 */ 结尾。任何位于 /* 和 */ 之间的文本都会被 JavaScript 忽略
多行注释（注释块），注释块常用于官方声明
/*
 下面的代码会改变
 网页中
 id = "myH" 的标题
 以及 id = "myP" 的段落：
*/

JavaScript 变量必须以唯一的名称的标识。这些唯一的名称称为标识符
标识符用于命名变量（以及关键词、函数和标签），首字符必须是字母、下划线（-）或美元符号（$）
JavaScript 标识符对大小写敏感，JavaScript 中的“等于”运算符是 ==
字符串被包围在双引号或单引号中。数值不用引号。如果把数值放在引号中，会被视作文本字符串
声明之后，变量是没有值的。（技术上，它的值是 undefined。）
var carName = "porsche";
document.getElementById("demo").innerHTML = carName; 
以逗号分隔变量var person = "Bill Gates", carName = "porsche", price = 15000;

如果再次声明某个 JavaScript 变量，将不会丢它的值。
var carName = "porsche";
var carName;
在这两条语句执行后，变量 carName 的值仍然是 "porsche"

字符串也可以使用加号，但是字符串将被级联（拼接）
var x = "8" + 3 + 5; 结果是835（一个是字符就会从这个字符开始之后全部当成字符，前面的依然是算数运算）
var x = 3 + 5 + "8";结果是88
z = "Hello" + 7;结果是Hello7 对数字和字符串相加，结果将是字符串！仅一个数字，遵从下面的括号
（第一个引号前的是数值，其后的全是字符）
z = 7 + 8 + "Hello" + 7;结果是15Hello7

系数运算符（%）返回除法的余数
取幂运算符（**）将第一个操作数提升到第二个操作数的幂，x ** y 产生的结果与 Math.pow(x,y) 相同
var x = 5;
var z = x ** 2;          // 结果是 25

当多个运算拥有相同的优先级时（比如加法和减法），对它们的计算是从左向右的

JavaScript 变量能够保存多种数据类型：数值、字符串值、数组、对象等等：
var length = 7;                             // 数字
var lastName = "Gates";                      // 字符串
var cars = ["Porsche", "Volvo", "BMW"];         // 数组
var x = {firstName:"Bill", lastName:"Gates"};    // 对象 

小数点.00不会显示出来
超大或超小的数值可以用科学计数法来写
var y = 123e5;      // 12300000
var z = 123e-5;     // 0.00123
数组索引基于零，这意味着第一个项目是 [0]，第二个项目是 [1]，以此类推

JavaScript 对象用花括号来书写。对象属性是 name:value 对，由逗号分隔
var person = {firstName:"Bill", lastName:"Gates", age:62, eyeColor:"blue"};
上例中的对象（person）有四个属性：firstName、lastName、age 以及 eyeColor

typeof 运算符返回变量或表达式的类型
typeof ""                  // 返回 "string"
typeof "Bill"              // 返回 "string"
typeof 0                   // 返回 "number"
typeof 314                 // 返回 "number"
typeof 运算符对数组返回 "object"，因为在 JavaScript 中数组属于对象
JavaScript 中，没有值的变量，其值是 undefined。typeof 也返回 undefined
空值与 undefined 不是一回事。空的字符串变量既有值也有类型  var car = "";                // 值是 ""，类型是 "string"
在 JavaScript 中，null 是 "nothing"。它被看做不存在的事物。不幸的是，在 JavaScript 中，null 的数据类型是对象
var person = null;           // 值是 null，但是类型仍然是对象（object)
可以通过设置值为 null 清空对象,也可以通过设置值为 undefined 清空对象
Undefined 与 null 的值相等，但类型不相等
null === undefined            // false(类型和值都等）
null == undefined             // true（值）

原始数据：原始数据值是一种没有额外属性和方法的单一简单数据值
typeof true                // 返回 "boolean"
string，number，undefined，boolean
复杂数据：function，object
typeof 运算符把对象、数组或 null 返回 object
typeof {name:'Bill', age:62} // 返回 "object"
typeof function myFunc(){}   // 返回 "function"

() 运算符调用函数,toCelsius 引用的是函数对象，而 toCelsius() 引用的是函数结果
不使用 () 访问函数将返回函数声明而不是函数结果：function toCelsius(f) { return (5/9) * (f-32); }
document.getElementById("demo").innerHTML = toCelsius;

对象也是变量。但是对象包含很多值,（JavaScript 对象中的）名称:值对被称为属性
方法以函数定义被存储在属性中:
var person = {
  firstName: "Bill",
  lastName : "Gates",
  id       : 678,
  fullName : function() {
    return this.firstName + " " + this.lastName;
  }
};

在函数定义中，this 引用该函数的“拥有者”。
在上面的例子中，this 指的是“拥有” fullName 函数的 person 对象。换言之，this.firstName 的意思是 this 对象的 firstName 属性
能够以两种方式访问属性：objectName.propertyName或者objectName["propertyName"]
person.lastName;或者person["lastName"];
能够通过如下语法访问对象方法：objectName.methodName()； name = person.fullName();
不使用 () 访问 fullName 方法，则将返回函数定义
方法实际上是以属性值的形式存储的函数定义

如果通过关键词 "new" 来声明 JavaScript 变量，则该变量会被创建为对象：
var x = new String();        // 把 x 声明为 String 对象
var y = new Number();        // 把 y 声明为 Number 对象
var z = new Boolean();       //	把 z 声明为 Boolean 对象
请避免字符串、数值或逻辑对象。他们会增加代码的复杂性并降低执行速度

字符串长度，内建属性 length 可返回字符串的长度
var y = "中国是瓷器的故乡，因此 china 与"China（中国）"同名。"该字符串将被切为 "中国是瓷器的故乡，因此 china 与"。
避免此问题的解决方法是，使用 \ 转义字符：var x = "中国是瓷器的故乡，因此 china 与\"China（中国）\"同名。"
\b	退格键
\f	换页
\n	新行
\r	回车
\t	水平制表符
\v	垂直制表符  这六个转义字符最初设计用于控制打字机、电传打字机和传真机。它们在 HTML 中没有任何意义
\'	'	单引号
\"	"	双引号
\\	\	反斜杠 有意义就这三个

同一个字符串内不能换行：
document.getElementById("demo").innerHTML = "Hello 
Kitty!";  错误
document.getElementById("demo").innerHTML =
"Hello Kitty.";  正确
可以在字符串中换行，通过一个反斜杠即可：
document.getElementById("demo").innerHTML = "Hello \
Kitty!";正确
\ 方法可能没有得到普遍的支持。较旧的浏览器可能会以不同的方式处理反斜杠周围的空格。一些旧的浏览器不允许 \ 字符后面的空格
对长字符串换行的最安全做法（但是有点慢）是使用字符串加法：
document.getElementById("demo").innerHTML = "Hello" + 
"Kitty!";
不能通过反斜杠对代码行进行换行：
document.getElementById("demo").innerHTML = \ 
"Hello Kitty!"; 错误
document.getElementById("demo").innerHTML = 
"Hello 
Kitty!"; 错误
document.getElementById("demo").innerHTML = 
"Hello \
Kitty!"; 正确
document.getElementById("demo").innerHTML = 
"Hello +
Kitty!"; 正确

字符串也可通过关键词 new 定义为对象：var firstName = new String("Bill")
两个对象无法比较，都会返回false：
var x = new String("Bill");             
var y = new String("Bill");
// (x ==/=== y) 为 false，因为 x 和 y 是不同的对象

通过 JavaScript，方法和属性也可用于原始值，因为在执行方法和属性时 JavaScript 将原始值视为对象
length 属性返回字符串的长度：var sln = txt.length;
字符串方法：
indexOf() 方法返回字符串中指定文本首次出现的索引（位置）：var pos = str.indexOf("China");（C刚出现的位置）(字符中有China就可以，Chinas也可以)
JavaScript 从零计算位置。0 是字符串中的第一个位置，1 是第二个，2 是第三个 ...
lastIndexOf() 方法返回指定文本在字符串中最后一次出现的索引
var str = "The full name of China is the People's Republic of China.";
var pos = str.lastIndexOf("China");（最后一个China的C出现的位置）
如果未找到文本， indexOf() 和 lastIndexOf() 均返回 -1
两种方法都接受作为检索起始位置的第二个参数
lastIndexOf() 方法向后进行检索（从尾到头），这意味着：假如第二个参数是 50，则从位置 50 开始检索，直到字符串的起点，位置 50 指的是从开头算起的位置 50
var pos = str.lastIndexOf("China", 50); 前面的最后一个（也就是从后往前第一个）

indexOf() 与 search()，是相等的
search() 方法无法设置第二个开始位置参数
indexOf() 方法无法设置更强大的搜索值（正则表达式）

slice() 提取字符串的某个部分并在新字符串中返回被提取的部分
该方法设置两个参数：起始索引（开始位置），终止索引（结束位置）
如果某个参数为负，则从字符串的结尾开始计数（最后一个是-1，倒数第二个是-2，slice(-13,-1),从-2开始到-13，共12个）
slice(2，7)从3开始到7
如果省略第二个参数，则该方法将裁剪字符串的剩余部分
var res = str.slice(7);从8到最后
var res = str.slice(-13);从-13到-1
都是从左到右到最后一个字符

substring() 类似于 slice()。不同之处在于 substring() 无法接受负的索引
substr() 类似于 slice()。不同之处在于第二个参数规定被提取部分的长度，如果省略第二个参数，则该 substr() 将裁剪字符串的剩余部分
第二个参数不能为负，因为它定义的是长度
规则同slice()

replace() 方法用另一个值替换在字符串中指定的值，replace() 方法不会改变调用它的字符串。它返回的是新字符串，replace() 对大小写敏感
默认地，replace() 只替换首个匹配（从左到右）
var n = str.replace("Microsoft", "W3School"); W3School替换Microsoft
如需执行大小写不敏感的替换，请使用正则表达式 /i（大小写不敏感）：var n = str.replace(/MICROSOFT/i, "W3School");（字母对就行）
如需替换所有匹配，请使用正则表达式的 g 标志（用于全局搜索）：var n = str.replace(/Microsoft/g, "W3School");

通过 toUpperCase() 把字符串转换为大写：var text2 = text1.toUpperCase();
通过 toLowerCase() 把字符串转换为小写

concat() 连接两个或多个字符串，下面两行是等效的：
var text = "Hello" + " " + "World!";
var text = "Hello".concat(" ","World!");
所有字符串方法都会返回新字符串。它们不会修改原始字符串

trim() 方法删除字符串两端的空白符：var str = "       Hello World!        ";  alert(str.trim());
charAt() 方法返回字符串中指定下标（位置）的字符串:(从0开始，找不到返回空字符串）
var str = "HELLO WORLD";
str.charAt(0);            // 返回 H
charCodeAt() 方法返回字符串中指定索引的字符 unicode 编码：
var str = "HELLO WORLD";
str.charCodeAt(0);         // 返回 72

对字符串的属性访问 [ ]：
var str = "HELLO WORLD";
str[0];                   // 返回 H
找不到字符，[ ] 返回 undefined
它是只读的。str[0] = "A" 不会产生错误（但也不会工作！）

可以通过 split() 将字符串转换为数组：
var txt = "a,b,c,d,e";   // 字符串
txt.split(",");          // 用逗号分隔 数组元素是 a b c d e ,a[0]是
txt.split(" ");          // 用空格分隔 数组元素是 a,b,c,d,e
txt.split("|");          // 用竖线分隔
（遇到分隔符算一个元素）
var str = "a,b,c,d,e,f";
var arr = str.split(",");  数组元素是 a b c d e f ,arr[0]是a
var arr = str.split(" ");  数组元素是 a,b,c,d,e,f ,arr[0]是a,b,c,d,e,f(只有一个元素）
如果省略分隔符split()，则arr[0]等于全部
如果分隔符是 ""，则一个字符是一个数组元素

整数（不使用指数或科学计数法）会被精确到 15 位（16位的全9就会舍入成1加16个0，其他的照常显示）
小数的最大数是 17 位，但是浮点的算数并不总是 100% 精准

在所有数字运算中，JavaScript 会尝试将字符串转换为数字：
var x = "100";
var y = "10";
var z = x / y;       // z 将是 10
（加法考虑级联，其他的数字运算）

0除以非零等于0，没有余数
a += 10 + 1; 变成a = a + 10 + 1;(*=,-=,%=,/=类似）
交换a,b的值：
1. var c = a; a = b; b = c;
2. a = a + b; b = a - b; a = a - b;

NaN - 非数值，NaN 属于 JavaScript 保留词，指示某个数不是合法数。尝试用一个非数字字符串进行除法会得到 NaN（Not a Number）：
var x = 100 / "Apple";  // x 将是 NaN（Not a Number）
不过，假如字符串包含数值，则结果将是数：var x = 100 / "10";     // x 将是 10
使用全局 JavaScript 函数 isNaN() 来确定某个值是否是数：var x = 100 / "Apple";
isNaN(x);               // 返回 true，因为 x 不是数
假如您在数学运算中使用了 NaN，则结果也将是 NaN
NaN 是数，typeof NaN 返回 number
和数字运算结果全为NaN, 和字符级联
0/0得到NaN

Infinity （或 -Infinity）是 JavaScript 在计算数时超出最大可能数范围时返回的值
除以 0（零）也会生成 Infinity
var x =  2 / 0;          // x 将是 Infinity
var y = -2 / 0;          // y 将是 -Infinity
Infinity 是数：typeOf Infinity 返回 number

JavaScript 会把前缀为 0x 的数值常量解释为十六进制
绝不要用前导零写数字（比如 07）。一些 JavaScript 版本会把带有前导零的数解释为八进制
toString() 方法把数输出为十六进制、八进制或二进制
var myNumber = 128;
myNumber.toString(16);     // 返回 80
myNumber.toString(8);      // 返回 200
myNumber.toString(2);      // 返回 10000000

通过关键词 new 定义为对象：var y = new Number(123)
var x = 123;// typeof x 返回 number
var y = new Number(123);// typeof y 返回 object
数字方法：
toString() 以字符串返回数值。所有数字方法可用于任意类型的数字（字面量、变量或表达式）
var x = 123;
x.toString();            // 从变量 x 返回 123
(123).toString();        // 从文本 123 返回 123
(100 + 23).toString();   // 从表达式 100 + 23 返回 123

toExponential() 返回字符串值，它包含已被四舍五入并使用指数计数法的数字。参数定义小数点后的字符数，该参数是可选的。
如果您没有设置它，JavaScript 不会对数字进行舍入

toFixed() 返回字符串值，它包含了指定位数小数的数字（四舍五入） toFixed(2) 非常适合处理金钱
toPrecision() 返回字符串值，它包含了指定长度的数字（四舍五入）整数加小数

valueOf() 以数值返回数值 数字可以是原始值（typeof = number）或对象（typeof = object）(to String()也一样)
在 JavaScript 内部使用 valueOf() 方法可将 Number 对象转换为原始值

这三种 JavaScript 方法可用于将变量转换为数字：
Number() 方法
parseInt() 方法
parseFloat() 方法
这些方法并非数字方法，而是全局 JavaScript 方法
Number() 可用于把 JavaScript 变量转换为数值，如果无法转换数字，则返回 NaN
x = "10 20"
Number(x);        // 返回 NaN
x = true;
Number(x);        // 返回 1
Number("John");   //返回NaN
Number() 还可以把日期转换为数字：Number(new Date("2019-04-15"));    // 返回 1506729600000
Number() 方法返回 1970 年 1 月 1 日至今的毫秒数

parseInt() 解析一段字符串并返回数值。允许空格,允许逗号。只返回首个数字：
parseInt("10.33");      // 返回 10
parseInt("10 20 30");   // 返回 10
parseInt("10 years");   // 返回 10
parseInt("years 10");   // 返回 NaN
如果无法转换为数值，则返回 NaN (Not a Number)

数值属性
MAX_VALUE 返回 JavaScript 中可能的最大数字 var x = Number.MAX_VALUE;
MIN_VALUE 返回 JavaScript 中可能的最小数字
var x = Number.POSITIVE_INFINITY;  返回Infinity
var x = Number.NEGATIVE_INFINITY;  返回-Infinity
var x = Number.NaN; 返回NaN  尝试使用非数字字符串进行算术运算（- * / %等）将导致 NaN（非数字）

数字属性不可用于变量
数字属性属于名为 number 的 JavaScript 数字对象包装器。
这些属性只能作为 Number.MAX_VALUE 访问。
使用 myNumber.MAX_VALUE，其中 myNumber 是变量、表达式或值，将返回 undefined

数组：
不要最后一个元素之后写逗号（比如 "BMW",）。可能存在跨浏览器兼容性问题
var cars = ["Saab", "Volvo", "BMW"];
var cars = new Array("Saab", "Volvo", "BMW");
出于简洁、可读性和执行速度的考虑，请使用第一种方法（数组文本方法）

访问完整数组
通过 JavaScript，可通过引用数组名来访问完整数组：
var cars = ["Saab", "Volvo", "BMW"];
document.getElementById("demo").innerHTML = cars; 

数组是一种特殊类型的对象。在 JavaScript 中对数组使用 typeof 运算符会返回 "object"
数组元素可以是对象
向数组添加新元素的最佳方法是使用 push() 方法：var fruits = ["Banana", "Orange", "Apple", "Mango"];  fruits.push("Lemon"); 
也可以使用 length 属性向数组添加新元素：fruits[fruits.length] = "Lemon";     // 向 fruits 添加一个新元素 (Lemon)

添加最高索引的元素可在数组中创建未定义的“洞”：var fruits = ["Banana", "Orange", "Apple", "Mango"];
fruits[6] = "Lemon";                 // 向 fruits 添加一个新元素 (Lemon)
4，5都是undefined

很多编程元素支持命名索引的数组。具有命名索引的数组被称为关联数组（或散列）。
JavaScript 不支持命名索引的数组。在 JavaScript 中，数组只能使用数字索引
使用命名索引，JavaScript 会把数组重定义为标准对象。之后，所有数组的方法和属性将产生非正确结果(没有定义数组，而是定义了很多对象）
var person = [];
person["firstName"] = "Bill";
person["lastName"] = "Gates";
person["age"] = 62;
var x = person.length;         // person.length 将返回 0
var y = person[0];              // person[0] 将返回 undefined

在 JavaScript 中，数组使用数字索引。在 JavaScript 中，对象使用命名索引。数组是特殊类型的对象，具有数字索引

没有必要使用 JavaScript 的内建数组构造器 new Array()，请使用 [] 取而代之！
new 关键词只会使代码复杂化。它还会产生某些不可预期的结果：var points = new Array(40, 100);  // 创建包含两个元素的数组（40 和 100）
假如删除其中一个元素会怎么样？var points = new Array(40);       // 创建包含 40 个未定义元素的数组！！！

如何识别数组：
Array.isArray()：document.getElementById("demo").innerHTML = Array.isArray(fruits);    // 返回 true
创建您自己的 isArray() 函数以解决此问题：
function isArray(x) {
    return x.constructor.toString().indexOf("Array") > -1;
}
假如对象原型包含单词 "Array" 则返回 true
假如对象由给定的构造器创建，则 instanceof 运算符返回 true：
var fruits = ["Banana", "Orange", "Apple", "Mango"];
document.getElementById("demo").innerHTML = fruits instanceof Array;     // 返回 true
instanceof见csdn，另外有3种判断方法可以看一下

数组方法：
toString() 把数组转换为数组值（逗号分隔）的字符串
document.getElementById("demo").innerHTML = fruits.toString(); 
join() 方法也可将所有数组元素结合为一个字符串。它的行为类似 toString()，但是您还可以规定分隔符：
默认是， document.getElementById("demo").innerHTML = fruits.join(" * "); 

pop() 方法从数组中删除最后一个元素，pop() 方法返回“被弹出”的值
document.getElementById("demo2").innerHTML = fruits.pop(); 返回的是弹出的值
push() 方法（在数组结尾处）向数组添加一个新的元素，push() 方法返回新数组的长度
shift() 方法会删除首个数组元素，并把所有其他元素“位移”到更低的索引，shift() 方法返回被“位移出”的字符串
unshift() 方法（在开头）向数组添加新元素，并“反向位移”旧元素，unshift() 方法返回新数组的长度

可以使用 JavaScript delete 运算符来删除 delete fruits[0];           // 把 fruits 中的首个元素改为 undefined
使用 delete 会在数组留下未定义的空洞。请使用 pop() 或 shift() 取而代之

splice() 方法可用于向数组添加新项：fruits.splice(2, 0, "Lemon", "Kiwi");
第一个参数（2）定义了应添加新元素的位置（拼接）
第二个参数（0）定义应删除多少元素（插入之后后面的元素，不留“空洞”的情况下移除元素）
其余参数（“Lemon”，“Kiwi”）定义要添加的新元素
splice() 方法返回一个包含已删除项的数组（由被删除的项组成的数组）

concat() 方法通过合并（连接）现有数组来创建一个新数组
concat() 方法不会更改现有数组。它总是返回一个新数组。concat() 方法可以使用任意数量的数组参数
var myChildren = arr1.concat(arr2, arr3);   // 将arr1、arr2 与 arr3 连接在一起

slice() 方法用数组的某个片段切出新数组（一个元素提取出来）
slice() 方法创建新数组。它不会从源数组中删除任何元素
slice() 可接受两个参数，比如 (1, 3)。该方法会从开始参数选取元素，直到结束参数（不包括）为止（1到2）
如果结束参数被省略，则 slice() 会切出数组的剩余部分（一个元素提取出来）

如果需要原始值，则 JavaScript 会自动把数组转换为字符串
document.getElementById("demo").innerHTML = fruits; 
结果和toString()相同

所有 JavaScript 对象都拥有 toString() 方法

sort() 方法以字母顺序对数组进行排序（A到Z）,fruits.sort();            // 对 fruits 中的元素进行排序
reverse() 方法反转数组中的元素。可以使用它以降序对数组进行排序

如果数字按照字符串来排序，则 "25" 大于 "100"，因为 "2" 大于 "1"。
正因如此，sort() 方法在对数值排序时会产生不正确的结果
通过一个比值函数来修正此问题
当 sort() 函数比较两个值时，会将值发送到比较函数，并根据所返回的值（负、零或正值）对这些值进行排序
当比较 40 和 100 时，sort() 方法会调用比较函数 function(40,100)。该函数计算 40-100，然后返回 -60（负值）。排序函数将把 40 排序为比 100 更低的值
points.sort(function(a, b){return a - b}); 升序
points.sort(function(a, b){return b - a}); 降序

以随机顺序排序数组
var points = [40, 100, 1, 5, 25, 10];
points.sort(function(a, b){return 0.5 - Math.random()});

JavaScript 不提供查找数组中最大或最小数组值的内建函数。不过，在对数组进行排序之后，您能够使用索引来获得最高或最低值（效率极低）
使用 Math.max.apply 来查找数组中的最高值：Math.max.apply(null, arr);
使用 Math.min.apply 来查找数组中的最低值：Math.min.apply(null, arr);
Math.max方法可以求出给定参数中最大的数，但如果是数组，就不能这样调用了。此时就用到了apply方法：
XXX.apply是一个调用函数的方法，其参数为：apply(Function, Args)，Function为要调用的方法，Args是参数列表，当Function为null时，默认为上文，
即Math.max.apply(null, arr)可认为是apply(Math.max, arr)
Math.min.apply([1, 2, 3]) 等于 Math.min(1, 2, 3)

即使对象拥有不同数据类型的属性，sort() 方法仍可用于对数组进行排序。解决方法是通过比较函数来对比属性值：
var cars = [{type:"Volvo", year:2016},{type:"Saab", year:2001},{type:"BMW", year:2010}];
cars.sort(function(a, b){return a.year - b.year});
比较字符串属性: 
cars.sort(function(a, b){
	  var x = a.type.toLowerCase();
	  var y = b.type.toLowerCase();
	  if (x < y) {return -1;}
	  if (x > y) {return 1;}
	  return 0;
});

forEach() 方法为每个数组元素调用一次函数（回调函数）:
numbers.forEach(myFunction);
function myFunction(value, index, array) {
  txt = txt + value + "<br>"; 
}
该函数接受 3 个参数：项目值|项目索引|数组本身

map() 方法通过对每个数组元素执行函数来创建新数组。map() 方法不会对没有值的数组元素执行函数。map() 方法不会更改原始数组
该函数接受 3 个参数：项目值|项目索引|数组本身
var numbers2 = numbers1.map(myFunction);
function myFunction(value, index, array) {
  return value * 2;
}

filter() 方法创建一个包含通过测试的数组元素的新数组
该函数接受 3 个参数：项目值|项目索引|数组本身
var over18 = numbers.filter(myFunction);
function myFunction(value, index, array) {
  return value > 18;
}

reduce() 方法在每个数组元素上运行函数，以生成（减少它）单个值。
reduce() 方法在数组中从左到右工作。另请参见 reduceRight（）。reduce() 方法不会减少原始数组
该函数接受 4 个参数：总数（初始值/先前返回的值）|项目值|项目索引|数组本身
确定数组中所有数字的总和：
var numbers1 = [45, 4, 9, 16, 25];
var sum = numbers1.reduce(myFunction);
function myFunction(total, value, index, array) {
  return total + value;
}
reduce() 方法能够接受一个初始值：var sum = numbers1.reduce(myFunction, 100);(没写默认为0(total)）

reduceRight()同reduce()不过从右往左，即从最后一项开始

every() 方法检查所有数组值是否通过测试
该函数接受 3 个参数：项目值|项目索引|数组本身
检查所有数组值是否大于 18：
var numbers = [45, 4, 9, 16, 25];
var allOver18 = numbers.every(myFunction);
function myFunction(value, index, array) {
  return value > 18;
}结果返回false

some() 方法检查某些数组值是否通过了测试
这个例子检查某些数组值是否大于 18（有值大于18就可以）：
var numbers = [45, 4, 9, 16, 25];
var someOver18 = numbers.some(myFunction);
function myFunction(value, index, array) {
  return value > 18;
}返回true

indexOf() 方法在数组中搜索元素值并返回其位置
注释：第一个项目的位置是 0，第二个项目的位置是 1，以此类推
var a = fruits.indexOf("Apple");
array.indexOf(item, start)
item	必需。要检索的项目。
start	可选。从哪里开始搜索。负值将从结尾开始的给定位置开始，并搜索到结尾（从2开始2有的话就是2)
开始查找的位置。如果该索引值大于或等于数组长度，意味着不会在数组里查找，返回-1。如果参数中提供的索引值是一个负值，则将其作为数组末尾的一个抵消，
即-1表示从最后一个元素开始查找，-2表示从倒数第二个元素开始查找 ，以此类推。 注意：如果参数中提供的索引值是一个负值，并不改变其查找顺序，
查找顺序仍然是从前向后查询数组。如果抵消后的索引值仍小于0，则整个数组都将会被查询。其默认值为0
从当前位置向后找，找到就返回索引（0，1，2，3...)，数组结束就停止，不循环
如果未找到项目，Array.indexOf() 返回 -1。如果项目多次出现，则返回第一次出现的位置
array.lastIndexOf(item, start)(从后往前）
item	必需。要检索的项目。
start	可选。从哪里开始搜索。负值将从结尾开始的给定位置开始，并搜索到开头
都返回数组元素在数组中的位序

find() 方法返回通过测试函数的第一个数组元素的值
该函数接受 3 个参数：项目值|项目索引|数组本身
findIndex() 方法返回通过测试函数的第一个数组元素的索引
该函数接受 3 个参数：项目值|项目索引|数组本身

new Date(year, month, ...) 用指定日期和时间创建新的日期对象
7个数字分别指定年、月、日、小时、分钟、秒和毫秒（按此顺序）（其他省略的默认是默认值）
您不能省略月份。如果只提供一个参数，则将其视为毫秒
一个参数会被解释为：new Date(milliseconds)。
Thu Jan 01 1970 08:00:02 GMT+0800 (中国标准时间)
显示的日期是起始日期距今2018毫秒（默认是1970年）

一位和两位数年份将被解释为 19xx 年：var d = new Date(99, 11, 24); var d = new Date(9, 11, 24);
new Date(dateString) 从日期字符串创建一个新的日期对象：var d = new Date("October 13, 2014 11:13:00");
JavaScript 将日期存储为自 1970 年 1 月 1 日 00:00:00 UTC（协调世界时）以来的毫秒数。零时间是 1970 年 1 月 1 日 00:00:00 UTC
1970 年 1 月 1 日减去 100 000 000 000 毫秒大约是 1966 年 10 月 31 日：var d = new Date(-100000000000);
一天（24 小时）是 86 400 000 毫秒
Date()返回的内容同new Date(),但Date()是字符串，new Date()是对象；

JavaScript（默认情况下）将以全文本字符串格式输出日期：Wed Mar 25 2015 08:00:00 GMT+0800 (中国标准时间)
在 HTML 中显示日期对象时，会使用 toString() 方法自动转换为字符串
toUTCString() 方法将日期转换为 UTC 字符串（一种日期显示标准）
toDateString() 方法将日期转换为更易读的格式：document.getElementById("demo").innerHTML = d.toDateString();

四种 JavaScript 日期输入格式：
ISO 日期	"2018-02-19" （国际标准）
短日期	"02/19/2018" 或者 "2018/02/19"
长日期	"Feb 19 2018" 或者 "19 Feb 2019"
完整日期	"Monday February 25 2015"
ISO 格式遵守 JavaScript 中的严格标准

ISO 8601 是表现日期和时间的国际标准
var d = new Date("2018-02-19"); 计算的日期相对于您的时区。根据您的时区，上面的结果将在 2 月 18 日至 2 月 19 日之间变化
写日期也可以添加时、分和秒 (YYYY-MM-DDTHH:MM:SS)：var d = new Date("2018-02-19T12:00:00");日期和时间通过大写字母 T 来分隔
UTC 时间通过大写字母 Z 来定义，希望修改相对于 UTC 的时间，请删除 Z 并用 +HH:MM 或 -HH:MM 代替
var d = new Date("2018-02-19T12:00:00-08:30");
UTC（Universal Time Coordinated）等同于 GMT（格林威治时间）

短日期：var d = new Date("02/19/2018");
某些浏览器中，不带前导零的月或其会产生错误
长日期：var d = new Date("Feb 19 2018"); 月和天能够以任意顺序出现，var d = new Date("19 Feb 2018");
月能够以全称 (January) 或缩写 (Jan) 来写，逗号会被忽略，且对大小写不敏感
完整日期：var d = new Date("Mon Feb 19 2018 06:55:23 GMT+0100 (W. Europe Standard Time)");
JavaScript 会忽略日期名称和时间括号中的错误

Date.now() 返回自零日期（1970 年 1 月 1 日 00:00:00:00）以来的毫秒数
getTime() 方法返回自 1970 年 1 月 1 日以来的毫秒数
document.getElementById("demo1").innerHTML = Date.now();
var d = new Date();
document.getElementById("demo2").innerHTML = d.getTime();
getFullYear() 方法以四位数字形式返回日期年份
var d = new Date();
document.getElementById("demo").innerHTML = d.getFullYear();
getMonth() 以数字（0-11）返回日期的月份：在 JavaScript 中，第一个月（1 月）是月号 0，因此 12 月返回月号 11
使用名称数组，并使用 getMonth() 将月份作为名称返回：
var d = new Date();
var months = 
            [
            "January", "February", "March", "April", "May", "June", 
            "July", "August", "September", "October", "November", "December"
            ];
document.getElementById("demo").innerHTML = months[d.getMonth()];

getDate() 方法以数字（1-31）返回日期的日
getHours() 方法以数字（0-23）返回日期的小时数
getMinutes() 方法以数字（0-59）返回日期的分钟数
getSeconds() 方法以数字（0-59）返回日期的秒数
getMilliseconds() 方法以数字（0-999）返回日期的毫秒数
getDay() 方法以数字（0-6）返回日期的星期名（weekday）（方法同getMonth())(Sunday=0, Monday=1, Tuesday=2 ..)
UTC 日期方法用于处理 UTC 日期（通用时区日期，Univeral Time Zone dates）:
getUTCDate()	等于 getDate()，但返回 UTC 日期 以此类推

setFullYear() 方法设置日期对象的年份：
var d = new Date();
d.setFullYear(2020);
setFullYear() 方法可以选择设置月和日：d.setFullYear(2020, 11, 3);

setMonth() 方法设置日期对象的月份（0-11）

setDate() 方法设置日期对象的日（1-31）
setDate() 方法也可用于将天数添加到日期
d.setDate(d.getDate() + 50); 如果添加天数，切换月份或年份，则更改将由 Date 对象自动处理

setHours() 方法设置日期对象的小时（0-23）
setMinutes() 方法设置日期对象的分钟（0-59）
setSeconds() 方法设置日期对象的秒数（0-59）

someday.setFullYear(2049, 0, 16);2049 年 1 月 16 日
if (someday > today) {
  text = "今天在 2049 年 1 月 16 日之前";
} 
JavaScript 从 0 到 11 计数月份。1 月是 0。12 月是 11

Math.PI;            // 返回 3.141592653589793
Math.round(x) 的返回值是 x 四舍五入为最接近的整数
Math.pow(x, y) 的返回值是 x 的 y 次幂
Math.sqrt(x) 返回 x 的平方根
Math.abs(x) 返回 x 的绝对（正）值
Math.ceil(x) 的返回值是 x 上舍入最接近的整数（上取整）：Math.ceil(6.4);     // 返回 7
Math.floor(x) 的返回值是 x 下舍入最接近的整数（下取整）
Math.sin(x) 返回角 x（以弧度计）的正弦（介于 -1 与 1 之间的值），希望使用角度替代弧度，则需要将角度转换为弧度
Math.sin(90 * Math.PI / 180);     // 返回 1（90 度的正弦）
Math.cos(x) 返回角 x（以弧度计）的余弦（介于 -1 与 1 之间的值）
Math.min() 和 Math.max() 可用于查找参数列表中的最低或最高值
Math.random() 返回介于 0（包括） 与 1（不包括） 之间的随机数

Math.E          // 返回欧拉指数（Euler's number）
Math.PI         // 返回圆周率（PI）
Math.SQRT2      // 返回 2 的平方根
Math.SQRT1_2    // 返回 1/2 的平方根
Math.LN2        // 返回 2 的自然对数
Math.LN10       // 返回 10 的自然对数
Math.LOG2E      // 返回以 2 为底的 e 的对数（约等于 1.414）
Math.LOG10E     // 返回以 10 为底的 e 的对数（约等于0.434）

与其他全局对象不同，Math对象没有构造函数(new后面的)。方法和属性是静态的
可以在不首先创建Math对象的情况下使用所有方法和属性（常量）

acos(x)	返回 x 的反余弦值，以弧度计
asin(x)	返回 x 的反正弦值，以弧度计
atan(x)	以介于 -PI/2 与 PI/2 弧度之间的数值来返回 x 的反正切值。
atan2(y,x)	返回从 x 轴到点 (x,y) 的角度
exp(x)	返回 Ex 的值
log(x)	返回 x 的自然对数（底为e）
tan(x)	返回角的正切

Math.floor(Math.random() * 10);		// 返回 0 至 9 之间的数
Math.floor(Math.random() * 11);		// 返回 0 至 10 之间的数
Math.floor(Math.random() * 100);	// 返回 0 至 99 之间的数
Math.floor(Math.random() * 10) + 1;	// 返回 1 至 10 之间的数
始终返回介于 min（包括）和 max（不包括）之间的随机数:Math.floor(Math.random() * (max - min) ) + min;
始终返回介于 min 和 max（都包括）之间的随机数:Math.floor(Math.random() * (max - min + 1) ) + min;

Boolean() 函数来确定表达式（或变量）是否为真
Boolean(10 > 9)        // 返回 true
具有“真实”值的即为 True
不具有“真实”值的即为 False 0,-0,""(空值),undefined,null,false,NaN

布尔可以是对象
var x = false;
var y = new Boolean(false);
// typeof x 返回 boolean
// typeof y 返回 object

不要创建布尔对象。它会拖慢执行速度。new 关键词会使代码复杂化，并产生某些意想不到的结果
!==	值不相等或类型不相等
===	值相等并且类型相等

字符串与数字进行比较，那么在做比较时 JavaScript 会把字符串转换为数值。空字符串将被转换为 0。非数值字符串将被转换为始终为 false 的 NaN
比较两个字符串时，"2" 大于 "12"，因为（按照字母排序）1 小于 2。为了确保正确的结果，在比较值前应该把变量转换为合适的类型
age = Number(age);
if (isNaN(age)) {
    voteable = "输入错误";
}

if 使用小写字母。大学字母（IF 或 If）会产生 JavaScript 错误
默认的 case 不必是 switch 代码块中最后一个 case
switch (new Date().getDay()) {
    default: 
        text = "期待周末！";
         break;
    case 6:
        text = "今天是周六";
        break; 
    case 0:
        text = "今天是周日";
} 
如果 default 不是 switch 代码块中最后一个 case，请记得用 break 结束默认 case

多种 case 匹配一个 case 值，则选择第一个 case。如果未找到匹配的 case，程序将继续使用默认 label。如果未找到默认 label，程序将继续 switch 后的语句
Switch case 使用严格比较（===）
var x = "0";
switch (x) {
  case 0:
    text = "Off";
    break;
  case 1:
    text = "On";
    break;
  default:
    text = "No value found";
}不匹配

for/in 语句遍历对象的属性：
var person = {fname:"Bill", lname:"Gates", age:62}; 
var text = "";
var x;
for (x in person) {
    txt += person[x] + " ";
}输出：Bill Gates 62

JavaScript 标签：如需标记 JavaScript 语句，请将标签名和冒号置于语句之前：
label:statements
break labelname; continue labelname;（break和continue跳出label指定的代码块）
continue 语句（不论有无标签引用）只能用于跳过一个迭代。
break 语句，如果没有标签引用，只能用于跳出一个循环或一个 switch。如果有标签引用，则 break 语句可用于跳出任意代码块
var  cars = ["BMW", "Volvo", "Saab", "Ford"];
list: {
    text += cars[0] + "<br>"; 
    text += cars[1] + "<br>"; 
    text += cars[2] + "<br>"; 
    break list;
    text += cars[3] + "<br>"; 
    text += cars[4] + "<br>"; 
    text += cars[5] + "<br>"; 
}代码块指的是 { 与 } 直接的代码片段

JavaScript 中有五种可包含值的数据类型：
字符串（string）
数字（number）
布尔（boolean）
对象（object）
函数（function）
有三种对象类型：
对象（Object）
日期（Date）
数组（Array）
同时有两种不能包含值的数据类型：
null
undefined

NaN 的数据类型是数值
数组的数据类型是对象
日期的数据类型是对象
null 的数据类型是对象
未定义变量的数据类型是 undefined
尚未赋值的变量的数据类型也是 undefined

typeof 运算符不是变量。它属于运算符。运算符（比如 + - * /）没有数据类型
constructor 属性返回所有 JavaScript 变量的构造器函数
"Bill".constructor                 // 返回 "function String()  { [native code] }"
(3.14).constructor                 // 返回 "function Number()  { [native code] }"
false.constructor                  // 返回 "function Boolean() { [native code] }"
[1,2,3,4].constructor              // 返回 "function Array()   { [native code] }"
{name:'Bill', age:62}.constructor  // 返回" function Object()  { [native code] }"
new Date().constructor             // 返回 "function Date()    { [native code] }"
function () {}.constructor         // 返回 "function Function(){ [native code] }"
可以通过检查 constructor 属性来确定某个对象是否为数组（包含单词 "Array"）
function isArray(myArray) {
    return myArray.constructor.toString().indexOf("Array") > -1;
}
或者更简单，您可以检查对象是否是数组函数：
function isArray(myArray) {
    return myArray.constructor === Array;
}

全局方法 String() 能够把数字、文字、变量、表达式或方法等转换为字符串
全局方法 Number() 可把字符串转换为数字
Number("3.14")    // 返回 3.14
Number(" ")       // 返回 0
Number("")        // 返回 0
Number("99 88")   // 返回 NaN
全局方法 Number() 也可把布尔转换为数字

一元的 + 运算符可用于把变量转换为数字：
var y = "5";      // y 是字符串
var x = + y;      // x 是数字
如果无法转换变量，则仍会成为数字，但是值为 NaN（Not a number）：
var y = "Bill";   // y 是字符串
var x = + y;      // x 是数字 (NaN)

5 + null    // 返回 5         因为 null 被转换为 0
"5" + null  // 返回 "5null"   因为 null 被转换为  "null"
"5" + 2     // 返回 52        因为 2 被转换为 "2"
"5" - 2     // 返回 3         因为 "5" 被转换为 5
"5" * "2"   // 返回 10        因为 "5" 和 "2" 被转换为 5 和 2

如果 myVar = {name:"Fjohn"}  // toString 转换为 "[object Object]"    (花括号不管内部写什么，包括不写都是显示为[object Object]）
详细见w3cschool js类型转换最后的转换表（有收藏）

<<	零填充左位移	通过从右推入零向左位移，并使最左边的位脱落。
>>	有符号右位移	通过从左推入最左位的拷贝来向右位移，并使最右边的位脱落。
>>>	零填充右位移	通过从左推入零来向右位移，并使最右边的位脱落

JavaScript 将数字存储为 64 位浮点数，但所有按位运算都以 32 位二进制数执行。在执行位运算之前，JavaScript 将数字转换为 32 位有符号整数。
执行按位操作后，结果将转换回 64 位 JavaScript 数
有符号整数使用最左边的位作为符号
11111111111111111111111111011000	-40
11111111111111111111111111011001	-41
进制的转换toString()
parseInt(bin, 2).toString(10);  bin以二进制解析取整后转换为十进制

正则表达式是构成搜索模式的字符序列。该搜索模式可用于文本搜索和文本替换操作
语法：/pattern/modifiers;
/w3school/i 是一个正则表达式。
w3school 是模式（pattern）（在搜索中使用）。
i 是修饰符（把搜索修改为大小写不敏感）

使用正则表达式执行搜索字符串中 "w3school" 的大小写不敏感的搜索：
var str = "Visit W3School";
var n = str.search(/w3school/i); 
n 中的结果将是：6
使用大小写不明的正则表达式以 W3school 来替换字符串中的 Microsoft：
var str = "Visit Microsoft!";
var res = str.replace(/microsoft/i, "W3School"); 
res 的结果将是：Visit W3School!
正则表达式可以使您的搜索更强大（例如，不区分大小写）
修饰符可用于大小写不敏感的更全局的搜素：
修饰符	描述
i	执行对大小写不敏感的匹配  var patt1 = /w3school/i;  var result = str.match(patt1);
g	执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）var patt1 = /is/g;  var result = str.match(patt1);
m	执行多行匹配  var patt1 = /^is/m;  在字符串中每行的开头对“is”进行多行搜索 (^是每行开头第一个（第一个字符或单词）的意思)
                      /^i/m;  找的是每行第一个字符是i
括号用于查找一定范围的字符串：
表达式	描述
[abc]	查找方括号之间的任何字符  var patt1 = /[h]/g; 所有的h都会显示出来   ，分隔开
[0-9]	查找任何从 0 至 9 的数字  var patt1 = /[1-4]/g;  1,2,3,4
(x|y)	查找由 | 分隔的任何选项（找x和y)  var patt1 = /(red|green)/g;  字符中所有的red和green都会显示出来
元字符（Metacharacter）是拥有特殊含义的字符：
元字符	描述
\d	查找数字    var patt1 = /\d/g;  字符串中所有数字都会显示出来   ，分隔开
\s	查找空白字符   var patt1 = /\s/g;  默认显示空格数减一个，
\b	匹配单词边界    var patt1 = /\bW3/g;  在字符串中单词的开头或结尾处对“W3”进行全局搜索(W3CHH可以，DW3不可以）
\uxxxx	查找以十六进制数 xxxx 规定的 Unicode 字符  var patt1 = /\u0057/g;  全局搜索字符串中的十六进制数0057（W）
Quantifiers 定义量词：
量词	描述
n+	匹配任何包含至少一个 n 的字符串   var patt1 = /o+/g;  每一段有多少个o都显示出来（只显示o）   ，分隔开   ooo,o,o,oo(下面的字符串)
n*	匹配任何包含零个或多个 n 的字符串   
var str = "Hellooo World! Hello W3School!"; var patt1 = /lo*/g;
全局搜索“l”，后跟零个或多个“o”字符：l,looo,l,l,lo,l
n?	匹配任何包含零个或一个 n 的字符串（跟0或不跟0就会显示，只显示跟的那一个0)
var str = "1, 100 or 1000?";  var patt1 = /10?/g;
全局搜索“1”，后跟零或一个“0”字符：1,10,10

使用 RegExp 对象
在 JavaScript 中，RegExp 对象是带有预定义属性和方法的正则表达式对象

test() 是一个正则表达式方法。它通过模式来搜索字符串，然后根据结果返回 true 或 false。
下面的例子搜索字符串中的字符 "e":
var patt = /e/;
patt.test("The best things in life are free!"); 返回true
简写：/e/.test("The best things in life are free!");

exec() 方法是一个正则表达式方法。它通过指定的模式（pattern）搜索字符串，并返回已找到的文本。如果未找到匹配，则返回 null。
下面的例子搜索字符串中的字符 "e"：
/e/.exec("The best things in life are free!");
由于字符串中有一个 "e"，以上代码的输出将是：e

正则表达式^和$不一定要配对，只是作为开头和结尾的一个标识
RegExp对象是正则表达式的缩写，有两种，字面量和new，所以定义var ttt=正则表达式(字面量形式)也是RegExp对象，可以用Reg.$1等方法
具体的正则见csdn收藏

try 语句使您能够测试代码块中的错误
catch 语句允许您处理错误
throw 语句允许您创建自定义错误
finally 使您能够执行代码，在 try 和 catch 之后，无论结果如何

try 语句允许您定义一个代码块，以便在执行时检测错误
catch 语句允许你定义一个要执行的代码块，如果 try 代码块中发生错误。
JavaScript 语句 try 和 catch 成对出现：
try {
     供测试的代码块
}
 catch(err) {(错误发生时的应执行的代码块)
     处理错误的代码块
} 

当发生错误时，JavaScript 通常会停止并产生错误消息
技术术语是这样描述的：JavaScript 将抛出异常（抛出错误）
JavaScript 实际上会创建带有两个属性的 Error 对象：name 和 message

throw 语句允许您创建自定义错误。从技术上讲您能够抛出异常（抛出错误）。异常可以是 JavaScript 字符串、数字、布尔或对象：
throw "Too big";    // 抛出文本
throw 500;          //抛出数字

try { (err=throw抛出的内容)
        if(x == "") throw "空的";
         if(isNaN(x)) throw "不是数字";
         x = Number(x);
        if(x < 5) throw  "太小";
        if(x > 10) throw "太大";
    }
catch(err) {
        message.innerHTML = "输入是 " + err;
    }
    
finally 语句允许您在 try 和 catch 之后执行代码，无论结果：finally {无论 try / catch 结果如何都执行的代码块}(放在try和catch之后）

JavaScript 拥有当错误发生时提供错误信息的内置 error 对象。error 对象提供两个有用的属性：name 和 message
name	设置或返回错误名
message	设置或返回错误消息（一条字符串）

name 属性可返回六个不同的值：
catch(err) {
    document.getElementById("demo").innerHTML = err.name;
} 
EvalError 指示 eval() 函数中的错误。更新版本的 JavaScript 不会抛出任何 EvalError。请使用 SyntaxError 代替
RangeError 会在您使用了合法值的范围之外的数字时抛出
假如您使用（引用）了尚未声明的变量，则 ReferenceError 会被抛出
假如您计算带语法错误的代码，会 SyntaxError 被抛出
假如您使用的值不在期望值的范围之内，则 TypeError 被抛出（类型错误）
假如您在 URI 函数中使用非法字符，则 URIError 被抛出

非标准的 Error 对象属性
Mozilla 和 Microsoft 定义了非标准的 error 对象属性：
fileName (Mozilla)
lineNumber (Mozilla)
columnNumber (Mozilla)
stack (Mozilla)
description (Microsoft)
number (Microsoft)
请勿在公共网站使用这些属性。它们并不会在所有浏览器中工作

作用域指的是您有权访问的变量集合
JavaScript 中有两种作用域类型：
局部作用域
全局作用域

JavaScript 函数中声明的变量，会成为函数的局部变量。局部变量的作用域是局部的：只能在函数内部访问它们
函数之外声明的变量，会成为全局变量
在 JavaScript 中，对象和函数也是变量
如果您为尚未声明的变量赋值，此变量会自动成为全局变量
myFunction();
// 此处的代码能够使用 carName 变量
function myFunction() {
    carName = "porsche";
}
在“严格模式”中不会自动创建全局变量
在 HTML 中，全局作用域是 window。所有全局变量均属于 window 对象
var carName = "porsche";
document.getElementById("demo").innerHTML = "我可以显示 " + window.carName;

JavaScript 变量的有效期始于其被创建时。局部变量会在函数完成时被删除。全局变量会在您关闭页面是被删除

Hoisting 是 JavaScript 将所有声明提升到当前作用域顶部的默认行为（提升到当前脚本或当前函数的顶部）
用 let 或 const 声明的变量和常量不会被提升！
JavaScript 只提升声明（var x;)，而非初始化（var x = 7;)(使用一个值前必须得有初始化，即赋值）
严格模式中的 JavaScript 不允许在未被声明的情况下使用变量

"use strict"; 定义 JavaScript 代码应该以“严格模式”执行，它不算一条语句，而是一段文字表达式
在脚本或函数的开头添加 "use strict"; 来声明严格模式
在脚本开头进行声明，拥有全局作用域（脚本中的所有代码均以严格模式来执行）：
"use strict";
x = 3.14;       // 这会引发错误，因为 x 尚未声明
在函数中声明严格模式，拥有局部作用域（只有函数中的代码以严格模式执行）
"use strict"; 只会对“理解”其含义的新编译器产生影响
在普通 JavaScript 中，如果向不可写属性赋值，开发者不会得到任何错误反馈
在严格模式中，向不可写的、只能读取的、不存在的属性赋值，或者向不存在的变量或对象赋值，将抛出错误

对象也是变量，在不声明对象的情况下使用对象也是不允许的
删除变量（或对象）是不允许的：
"use strict";
var x = 3.14;
delete x;                // 这将引发错误
删除函数是不允许的 function x(p1, p2) {};   delete x;    // 这将引发错误
重复参数名是不允许的 function x(p1, p1) {};   // 这将引发错误
八进制数值文本是不允许的 var x = 010;             // 这将引发错误
转义字符是不允许的：var x = \010;            // 这将引发错误
写入只读属性是不允许的
写入只能获取的属性是不允许的
删除不可删除的属性是不允许的
字符串 "eval" 不可用作变量
字符串 "arguments" 不可用作变量
with 语句是不允许的 with (Math){x = cos(2)}; // 这将引发错误
处于安全考虑，不允许 eval() 在其被调用的作用域中创建变量：eval ("var x = 2");     alert (x);               // 这将引发错误
在类似 f() 的函数调用中，this 的值是全局对象。在严格模式中，现在它成为了 undefined

严格模式中不允许使用为未来预留的关键词。它们是：
implements
interface
let
package
private
protected
public
static
yield

"use strict" 指令只能在脚本或函数的开头被识别

JavaScript this 关键词指的是它所属的对象
在对象方法中，this 指的是此方法的“拥有者”
person 对象是 fullName 方法的拥有者
fullName : function() {
  return this.firstName + " " + this.lastName;
}

单独的this:
在单独使用时，拥有者是全局对象，因此 this 指的是全局对象。在浏览器窗口中，全局对象是 [object Window]
var x = this;  （结果显示[object Window]）
在严格模式中，如果单独使用，那么 this 指的是全局对象 [object Window]（结果显示[object Window]）

在 JavaScript 函数中，函数的拥有者默认绑定 this
在函数中，this 指的是全局对象 [object Window]
function myFunction() {
  return this;
} （结果显示[object Window]）
JavaScript 严格模式不允许默认绑定。因此，在函数中使用时，在严格模式下，this 是未定义的（undefined）
在此例中，this 是 person 对象（person 对象是该函数的“拥有者”）：
var person = {
  firstName  : "Bill",
  lastName   : "Gates",
  id         : 678,
  myFunction : function() {
    return this;
  }
};

在 HTML 事件处理程序中，this 指的是接收此事件的 HTML 元素：<button onclick="this.style.display='none'">点击来删除我！</button>

显式函数绑定
call() 和 apply() 方法是预定义的 JavaScript 方法。它们都可以用于将另一个对象作为参数调用对象方法
在下面的例子中，当使用 person2 作为参数调用 person1.fullName 时，this 将引用 person2，即使它是 person1 的方法：
var person1 = {
  fullName: function() {
    return this.firstName + " " + this.lastName;
  }
}
var person2 = {
  firstName:"Bill",
  lastName: "Gates",
}
person1.fullName.call(person2);  // 会返回 "Bill Gates"

通过 var 关键词声明的变量没有块作用域。在块 {} 内声明的变量可以从块之外进行访问
var x = 10;
// 此处 x 为 10
{ 
  var x = 6;
  // 此处 x 为 6
}
// 此处 x 为 6
使用 let 关键词声明拥有块作用域的变量。在块 {} 内声明的变量无法从块外访问：
{ 
  let x = 10;
}
// 此处不可以使用 x

使用 var 关键字重新声明变量会带来问题。在块中重新声明变量也将重新声明块外的变量
var x = 10;
// 此处 x 为 10
{ 
  var x = 6;
  // 此处 x 为 6
}
// 此处 x 为 6
使用 let 关键字重新声明变量可以解决这个问题。在块中重新声明变量不会重新声明块外的变量：
var x = 10;
// 此处 x 为 10
{ 
  let x = 6;
  // 此处 x 为 6
}
// 此处 x 为 10

在循环中用 let 声明了变量 i，那么只有在循环内，变量 i 才是可见的
let i = 7;
for (let i = 0; i < 10; i++) {
  // 一些语句
}
// 此处 i 为 7

在函数内声明变量时，使用 var 和 let 很相似;(函数作用域）  在块外声明声明，那么 var 和 let 也很相似；（全局作用域）
使用 JavaScript 的情况下，全局作用域是 JavaScript 环境。在 HTML 中，全局作用域是 window 对象
var carName = "porsche";
// 此处的代码可使用 window.carName
通过 let 关键词定义的全局变量不属于 window 对象：
let carName = "porsche";
// 此处的代码不可使用 window.carName
（可以全局，但不可以用window.）

允许在程序的任何位置使用 var 重新声明 JavaScript 变量
在相同的作用域，或在相同的块中，通过 let 重新声明一个 var 变量是不允许的：
var x = 10;       // 允许
let x = 6;       // 不允许

{
  var x = 10;   // 允许
  let x = 6;   // 不允许
}
在相同的作用域，或在相同的块中，通过 let 重新声明一个 let 变量是不允许的：
let x = 10;       // 允许
let x = 6;       // 不允许

{
  let x = 10;   // 允许
  let x = 6;   // 不允许
}
在相同的作用域，或在相同的块中，通过 var 重新声明一个 let 变量是不允许的：
let x = 10;       // 允许
var x = 6;       // 不允许

{
  let x = 10;   // 允许
  var x = 6;   // 不允许
}
在不同的作用域或块中，通过 let 重新声明变量是允许的：
let x = 6;       // 允许

{
  let x = 7;   // 允许
}

{
  let x = 8;   // 允许
}

通过 let 定义的变量不会被提升到顶端。在声明 let 变量之前就使用它会导致 ReferenceError。变量从块的开头一直处于“暂时死区”，直到声明为止：

通过 const 定义的变量与 let 变量类似，但不能重新赋值
let x=3;
x=4;
结果是4；

const PI = 3.141592653589793;
PI = 3.14;      // 会出错
PI = PI + 10;   // 也会出错
在块作用域内使用 const 声明的变量与 let 变量相似
JavaScript const 变量必须在声明时赋值：
const PI;
PI = 3.14159265359;（错误）

关键字 const 有一定的误导性。它没有定义常量值。它定义了对值的常量引用。因此，我们不能更改常量原始值，但我们可以更改常量对象的属性
const car = {type:"porsche", model:"911", color:"Black"};
// 您可以更改属性：
car.color = "White";
// 您可以添加属性：
car.owner = "Bill";
但是您无法重新为常量对象赋值：
const car = {type:"porsche", model:"911", color:"Black"};
car = {type:"Volvo", model:"XC60", color:"White"};    // ERROR

可以更改常量数组的元素：
// 您可以创建常量数组：
const cars = ["Audi", "BMW", "porsche"];
// 您可以更改元素：
cars[0] = "Honda";
// 您可以添加元素：
cars.push("Volvo");
无法重新为常量数组赋值：
const cars = ["Audi", "BMW", "porsche"];
cars = ["Honda", "Toyota", "Volvo"];    // ERROR

在同一作用域或块中，不允许将已有的 var 或 let 变量重新声明或重新赋值给 const：
var x = 2;         // 允许
const x = 2;       // 不允许
{
  let x = 2;     // 允许
  const x = 2;   // 不允许
}
在同一作用域或块中，为已有的 const 变量重新声明声明或赋值是不允许的：
const x = 2;       // 允许
const x = 3;       // 不允许
x = 3;             // 不允许
var x = 3;         // 不允许
let x = 3;         // 不允许
{
  const x = 2;   // 允许
  const x = 3;   // 不允许
  x = 3;         // 不允许
  var x = 3;     // 不允许
  let x = 3;     // 不允许
}
在另外的作用域或块中重新声明 const 是允许的：
const x = 2;       // 允许
{
  const x = 3;   // 允许
}
{
  const x = 4;   // 允许
}

通过 const 定义的变量不会被提升到顶端。const 变量不能在声明之前使用

在调试窗口中，您可在 JavaScript 代码中设置断点。在每个断点中，JavaScript 将停止执行，以使您能够检查 JavaScript 的值。在检查值之后，您可以恢复代码执行

debugger 关键词会停止 JavaScript 的执行，并调用（如果有）调试函数。
这与在调试器中设置断点的功能是一样的。如果调试器不可用，debugger 语句没有效果。如果调试器已打开，此代码会在执行第三行之前停止运行
var x = 15 * 5;
debugger;
document.getElementbyId("demo").innerHTML = x;

请始终使用对代码块缩进使用 4 个空格
请不要对缩进使用制表符。不同的编辑器对 tab 的解释也不尽相同
对象属性之间用，分隔开 数组元素之间用，分隔开
变量和函数名以驼峰大小写来写
全局变量使用大写（我们不这样做，但是相当普遍）
常量（比如 PI）使用大写
JavaScript 命名不允许使用连字符
JavaScript 命名请不要以 $ 符号开头。此举会引起 JavaScript 库名称冲突
使用小写文件名

避免全局变量，全局变量和函数可被其他脚本覆盖。请使用局部变量替代，并学习如何使用闭包
局部变量必须通过 var 关键词来声明，否则它们将变成全局变量。严格模式不允许未声明的变量
默认地，JavaScript 会将所有声明移至顶部（JavaScript hoisting）
不要声明数值、字符串或布尔对象，请始终将数值、字符串或布尔值视作原始值，如果把这些类型声明为对象，会拖慢执行速度，并产生讨厌的副作用

请使用 {} 来代替 new Object()
请使用 "" 来代替 new String()
请使用 0 来代替 new Number()
请使用 false 来代替 new Boolean()
请使用 [] 来代替 new Array()
请使用 /()/ 来代替 new RegExp()
请使用 function (){}来代替 new Function()
var x1 = {};           // 新对象
var x2 = "";           // 新的原始字符串值
var x3 = 0;            // 新的原始数值
var x4 = false;        // 新的原始布尔值
var x5 = [];           // 新的数组对象
var x6 = /()/;         // 新的正则表达式
var x7 = function(){}; // 新的函数对象

字符串减去字符串，不会产生错误而是返回 NaN（Not a Number）
如果调用函数时缺少一个参数，那么这个缺失参数的值会被设置为 undefined。undefined 值会破坏您的代码。为参数设置默认值是一个好习惯。
function myFunction(x, y) {
    if (y === undefined) {
        y = 0;
    }
}
避免使用 eval()，eval() 函数用于将文本作为代码来允许。在几乎所有情况下，都没有必要使用它。因为允许任意代码运行，它同时也意味着安全问题

有一个常见的错误是忘记在 switch 语句中使用严格比较
JavaScript 中的数字均保存为 64 位的浮点数（Floats）。所有编程语言，包括 JavaScript，都存在处理浮点值的困难
为了解决上面的问题，请使用乘除运算
在一行的结尾自动关闭语句是默认的 JavaScript 行为。JavaScript 会在行末关闭 return 语句，因为它本身就是一条完整的语句。
所以，绝不要对 return 语句进行换行（一行中完整语句会自动加分号，var不是完整语句，JavaScript 将通过读取下一行来完成这条语句，因此可以换行）

用逗号来结束定义，对象和数组定义中的尾随逗号在 ECMAScript 5 中是合法的，Internet Explorer 8 会崩溃。JSON 不允许尾随逗号
points = [35, 450, 2, 7, 30, 16,];（最好不用）

JavaScript 对象、变量、属性和方法可以是未定义的  
空的 JavaScript 对象的值可以为 null(也可以是undefined)，会使测试对象是否为空变得有点困难。您可以通过测试类型是否为 undefined，来测试对象是否存在
if (typeof myObj === "undefined")(其实==就可以了）
无法测试对象是否为 null，因为如果对象未定义，将抛出错误（测值是不是null):if (myObj == null)
在测试非 null 之前，必须先测试未定义：if (typeof myObj !== "undefined" && myObj !== null)
document.getElementById("demo").innerHTML = typeof myObj !== "undefined" && myObj !== null;（返回布尔值）

for (var i = 0; i < 10; i++) {
  // some code
}
document.getElementById("demo").innerHTML = i; 显示10； var可以，let,const不可以

减少循环中的活动
差的代码：
var i;
for (i = 0; i < arr.length; i++) {
更好的代码：
var i;
var l = arr.length;
for (i = 0; i < l; i++) {
循环每次迭代时，坏代码就会访问数组的 length 属性。好代码在循环之外访问 length 属性，使循环更快

减少 DOM 访问
与其他 JavaScript 相比，访问 HTML DOM 非常缓慢。假如您期望访问某个 DOM 元素若干次，那么只访问一次，并把它作为本地变量来使用：
var obj;
obj = document.getElementById("demo");
obj.innerHTML = "Hello"; 
之后都可以用obj. 来说明内容（减少document.的使用）

缩减 DOM 规模
请尽量保持 HTML DOM 中较少的元素数量。这么做总是会提高页面加载，并加快渲染（页面显示），尤其是在较小的设备上

避免不必要的变量请不要创建不打算存储值的新变量。
通常您可以替换代码：
var fullName = firstName + " " + lastName;
document.getElementById("demo").innerHTML = fullName; 
用这段代码：document.getElementById("demo").innerHTML = firstName + " " + lastName

把脚本放在页面底部，使浏览器首先加载页面
脚本在下载时，浏览器不会启动任何其他的下载。此外所有解析和渲染活动都可能会被阻塞
HTTP 规范定义浏览器不应该并行下载超过两种要素。
一个选项是在 script 标签中使用 defer="true"。defer 属性规定了脚本应该在页面完成解析后执行，但它只适用于外部脚本。
如果可能，您可以在页面完成加载后，通过代码向页面添加脚本：
<script>
window.onload = downScripts;
function downScripts() {
    var element = document.createElement("script");
    element.src = "myScript.js";
    document.body.appendChild(element);
}
</script>

避免使用 with 关键词。它对速度有负面影响。它也将混淆 JavaScript 作用域。严格模式中不允许 with 关键词
ECMAScript 5 允许在对象和数组定义中使用尾随逗号
person = {
  firstName: "Bill",
  lastName: " Gates",
  age: 62,
}
Internet Explorer 8 将崩溃。JSON 不允许使用尾随逗号

ECMAScript 5允许保留字作为属性名称：var obj = {name: "Bill", new: "yes"}

ES6 允许函数参数具有默认值
function myFunction(x, y = 10) {
  // y is 10 if not passed or undefined
  return x + y;
}
myFunction(5); // 将返回 15（只给一个参数，另一个是undefined，会出错，有了默认值就不会）

ES6 将以下属性添加到 Number 对象：
EPSILON 2.220446049250313e-16
MIN_SAFE_INTEGER -9007199254740991
MAX_SAFE_INTEGER 9007199254740991

如果参数是整数，则 Number.isInteger() 方法返回 true
安全整数是可以精确表示为双精度数的整数。如果参数是安全整数，则 Number.isSafeInteger() 方法返回 true
安全整数指的是从 -9007199254740991 到 9007199254740991 的所有整数

如果参数为 Infinity 或 NaN，则全局 isFinite() 方法返回 false，否则返回 true
如果参数是 NaN，则全局 isNaN() 方法返回 true。否则返回 false

箭头函数允许使用简短的语法来编写函数表达式。您不需要 function 关键字、return 关键字以及花括号
const x = (x, y) => x * y;
箭头功能没有自己的 this。它们不适合定义对象方法。箭头功能未被提升。它们必须在使用前进行定义。
使用 const 比使用 var 更安全，因为函数表达式始终是常量值。
如果函数是单个语句，则只能省略 return 关键字和花括号。因此，保留它们可能是一个好习惯：
const x = (x, y) => { return x * y };

JSON 是存储和传输数据的格式。JSON 经常在数据从服务器发送到网页时使用
JSON 指的是 JavaScript Object Notation
JSON 的语法是来自 JavaScript 对象符号的语法，但 JSON 格式是纯文本。读取和生成 JSON 数据的代码可以在任何编程语言编写的
JSON 语法规则
数据是名称/值对
数据由逗号分隔
花括号保存对象
方括号保存数组
"firstName":"Bill" JSON 名称需要双引号。JavaScript 名称不需要
数组：
"employees":[
    {"firstName":"Bill", "lastName":"Gates"}, 
    {"firstName":"Steve", "lastName":"Jobs"}, 
    {"firstName":"Alan", "lastName":"Turing"}
]

JSON.parse()
JSON 的一个常见用途是从 Web 服务器接收数据。
想象一下，您从Web服务器收到这条文本字符串：
'{"name":"Bill", "age":62, "city":"Seatle"}'
JavaScript 函数 JSON.parse() 用于将文本转换为 JavaScript 对象：var obj = JSON.parse('{"name":"Bill", "age":62, "city":"Seatle"}');
obj = JSON.parse(text);
document.getElementById("demo").innerHTML =
obj.employees[1].firstName + " " + obj.employees[1].lastName;

JSON.stringify()
JSON 的一个常见用途是将数据发送到Web服务器。
将数据发送到 Web 服务器时，数据必须是字符串。
想象一下，我们在 JavaScript 中有这个对象：
var obj = {"name":"Bill", "age":62, "city":"Seatle"};
请使用 JavaScript 函数 JSON.stringify() 将其转换为字符串。
var myJSON = JSON.stringify(obj);结果将是遵循 JSON 表示法的字符串

原型适合封装方法，如果每个对象都有一个方法，一个方法复制很多次，一个对象分配一个，就会占空间
具体的原型和构造函数等见csdn收藏

a = "b" + true + 1;  结果是a = btrue1
就是简单的自左向右，然后碰到字符串就变成字符串
var a = 1; a = a-- + --a; 则a = 0;  
--a和++a（放前面的）先算，然后再算a++,a--（放后面的），最后算+ 如果有多个放前面的（不管加减），就从左到右，其他的相同
比较字符串，先比第一个字符的ASCII，再比第二个（两个字符的第二个，即第一个和第一个比，第二个和第二个比）
undefined == undefined  true
Infinity == Infinity  true
Infinity == Infinity + 1  true
NaN == NaN  false(NaN不等于任何，包括自己）

null才是空占位符，Null，NULL等其他的都是变量名
undefined,null,"",NaN,0,false 转换为布尔值都是false

&&: 
1、a && b; 看a转化成布尔值，如果是false,就直接返回a的值，如果a是true，然后返回b的值(只有两个数a,b，所以一定返回b）
2、a && b + 1; 同样先看a的布尔值，false就变成a;  如果a是true,就变成b + 1; （算术运算符优先级大于逻辑，因此先算b+1，b+1是一个整体）
3、a && b && c; 从左到右一次判定，规则同上
如果满足第一个就执行第二个的判断作用：2>1 && document.write("hello");
