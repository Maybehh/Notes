偶合就是重复的意思
编程要高内聚，弱偶合

直接document.write()函数名，输出的是function 函数名(){方法体} （就是打印整个函数）
console.log()相当于是在body内部的最后加了个script标签，然后在里面写代码，因此可以输出页面中所有出现过的东西

函数声明：function functionName(parameters) {
   要执行的代码
}
被声明的函数不会直接执行。它们被“保存供稍后使用”，将在稍后执行，当它们被调用时
分号用于分隔可执行的 JavaScript 语句。由于函数声明不是可执行的语句，以分号结尾并不常见

函数参数的个数不必一一对应，如fn(a,b); 可以fn(1,2,3);这样就只用前两个，每个实参的类型亦可以不同（因此不能有两个同名的函数，编译不过）
fn(a,b,c); 可以fn(1,2);因为在函数体内var abc，c没有传值，就是undefined
利用这个特性可以写函数求得任意个数的数的总和(使用arguments)，不然就得把数字写成数组形式传入函数，在函数内再去加

调用的函数传过去的实参会全部记录在函数的arguments数组里（实参列表），通过调用arguments[i]，可以获得传入的每一个实参
fn(a,b,c)通过fn.length可以获得形参的个数，arguments.length可以获得实参的个数

fn(a,b); 其中a和arguments[0]其中有任意一个变，另一个都得跟着变；a和arguments[0]不是指向同一个地址，是两个不同的地址，但是系统内有一个映射规则规定了
一个变另一个得跟着变
但是比如fn(a,b); fn(1); arguments里只有一个1,这个时候函数内部写b=2,arguments[1]不会变，因为压根没有，此时打印arguments[1]输出undefined
arr = [1,2,34,5]; 输出arr[4]是undefined

函数表达式可以在变量中存储：var x = function (a, b) {return a * b};(在函数体里var了a,b两个变量，然后把参数值赋给他们）
在变量中保存函数表达式之后，此变量可用作函数：
var x = function (a, b) {return a * b};（参数a,b直接写就好了，不用写int a等，js没有int等，也不用写var)
var z = x(4, 3);
存放在变量中的函数不需要函数名。他们总是使用变量名调用。上面的函数使用分号结尾，因为它是可执行语句的一部分
函数表达式有两种，命名函数表达式（var test = function abc(){};）和匿名函数表达式（var x = function (a, b) {return a * b};）
往后一般把函数表达式默认为匿名函数表达式
var test = function abc(){} 其中abc()不能执行函数，是undefined,只能用test();   
因为function abc(){}是函数表达式，表达式是忽略函数名的（写了会自动忽略），只能用变量名()调用

函数（包括表达式和声明）有个属性，test.name打印的是abc
demo = function(){}  demo.name打印的是demo
function hh(){}   hh.name打印的是hh

如果我们没写return的话函数自动在最后加上return;

Function() 构造器：var myFunction = new Function("a", "b", "return a * b");
大多数情况下，您可以避免在 JavaScript 中使用 new 关键词

Hoisting 应用于变量声明和函数声明。正因如此，JavaScript 函数能够在声明之前被调用：
myFunction(5);
function myFunction(y) {
     return y * y;
}
使用表达式定义的函数不会被提升

函数表达式可以作为“自调用”。自调用表达式是自动被调用（开始）的，在不进行调用的情况下。函数表达式会自动执行，假如表达式后面跟着 ()。
您无法对函数声明进行自调用。您需要在函数周围添加括号，以指示它是一个函数表达式：
(function () {
    var x = "Hello!!";      //我会调用我自己
})();
上面的函数实际上是一个匿名的自调用函数（没有名称的函数）

JavaScript 函数可被用作值：var x = myFunction(4, 3);
JavaScript 函数可用在表达式中：var x = myFunction(4, 3) * 2;

JavaScript 中的 typeof 运算符会为函数返回 "function"。但是最好是把 JavaScript 函数描述为对象。JavaScript 函数都有属性和方法。
arguments.length 会返回函数被调用时收到的参数数目：function myFunction(a, b) {return arguments.length;}

toString() 方法以字符串返回函数：document.getElementById("demo").innerHTML = myFunction.toString();
返回function myFunction(a, b) { return a * b; }

定义为对象属性的函数，被称为对象的方法。为创建新对象而设计的函数，被称为对象构造函数（对象构造器）

函数参数（parameter）指的是在函数定义中列出的名称。函数参数（argument）指的是传递到函数或由函数接收到的真实值
JavaScript 函数定义不会为参数（parameter）规定数据类型。JavaScript 函数不会对所传递的参数（argument）实行类型检查。
JavaScript 函数不会检查所接收参数（argument）的数量

JavaScript 函数有一个名为 arguments 对象的内置对象。arguments 对象包含函数调用时使用的参数数组。
这样，您就可以简单地使用函数来查找（例如）数字列表中的最高值：
x = findMax(1, 123, 500, 115, 44, 88);
function findMax() {
    var i;
    var max = -Infinity;
    for (i = 0; i < arguments.length; i++) {
        if (arguments[i] > max) {
            max = arguments[i];
        }
    }
    return max;
}

JavaScript 参数通过值传递：函数只知道值，而不是参数的位置。如果函数改变了参数的值，它不会改变参数的原始值。参数的改变在函数之外是不可见的
在 JavaScript 中，对象引用是值。正因如此，对象的行为就像它们通过引用来传递：如果函数改变了对象属性，它也改变了原始值。对象属性的改变在函数之外是可见的

在函数被定义时，函数内部的代码不会执行。在函数被调用时，函数内部的代码会被执行
以函数形式调用函数：function myFunction(a, b) { return a * b; }       myFunction(10, 2);           // 将返回 20
以上函数不属于任何对象。但是在 JavaScript 中，始终存在一种默认的全局对象。
在 HTML 中，默认全局对象是 HTML 页面本身，所有上面的函数“属于”HTML 页面。在浏览器中，这个页面对象就是浏览器窗口。上面的函数自动成为一个窗口函数。
myFunction() 和 window.myFunction() 是同一个函数：
function myFunction(a, b) {
    return a * b;
}
window.myFunction(10, 2);    // 也会返回 20
这是调用函数的常见方法，但并不是一个好习惯。全局变量、方法或函数很容易在全局对象中产生命名冲突和漏洞

当不带拥有者对象调用对象时，this 的值成为全局对象。在 web 浏览器中，全局对象就是浏览器对象。
本例以 this 的值返回这个 window 对象：（myFunction没有对象拥有它，于是this成为全局对象）
var x = myFunction();
function myFunction() {
  return this;
}
document.getElementById("demo").innerHTML = x; 返回[object Window]（返回普通对象就是[object Object])

调用一个函数作为一个全局函数，会导致 this 的值成为全局对象，作为变量来使用 window 对象很容易使程序崩溃
var myObject = {
    firstName:"John",
    lastName: "Doe",
    fullName: function () {
        return this;（this是myObject,也就是return myObject)
    }
}
myObject.fullName();          // 将返回 [object Object]（拥有者对象）

通过函数构造器来调用函数：它看起来像你创建一个新的函数，但由于 JavaScript 函数是对象，你实际上创建一个新对象
构造器调用会创建新对象。新对象会从其构造器继承属性和方法，构造器内的 this 关键词没有值。this 的值会成为调用函数时创建的新对象

fullName 属性属于 person 对象的方法
call() 方法是预定义的 JavaScript 方法。它可以用来调用所有者对象作为参数的方法(改变this的指向）
var person = {
    fullName: function() {
        return this.firstName + " " + this.lastName;
    }
}
var person1 = {
    firstName:"Bill",
    lastName: "Gates",
}
var person2 = {
    firstName:"Steve",
    lastName: "Jobs",
}
person.fullName.call(person1);  // 将返回 "Bill Gates" （调用person的fullName()方法，改变fullName()方法中的this的指向为person1)
带参数的call()：
var person = {
  fullName: function(city, country) {
    return this.firstName + " " + this.lastName + "," + city + "," + country;
  }
}
var person1 = {
  firstName:"Bill",
  lastName: "Gates"
}
person.fullName.call(person1, "Seattle", "USA");（第一个是this指向的对象,后续是fullName()方法的参数列表）

apply() 方法与 call() 方法非常相似，不同之处是：call() 方法分别接受参数。apply() 方法接受数组形式的参数。
如果要使用数组而不是参数列表，则 apply() 方法非常方便
var x = person.fullName.apply(person1, ["Seatle", "USA"]); 
Math.max.apply(null, [1,2,3]); // 也会返回 3（Math.max没有this，所以可以指向其他)
Math.max.apply(Math, [1,2,3]); // 也会返回 3
Math.max.apply(" ", [1,2,3]); // 也会返回 3
Math.max.apply(0, [1,2,3]); // 也会返回 3
详见uc收藏

在 JavaScript 严格模式下，如果 apply() 方法的第一个参数不是对象，则它将成为被调用函数的所有者（对象）。在“非严格”模式下，它成为全局对象
call调用方法给call里的对象用（因为this指向了它，方法里有this），call里的对象本来可以没有那个方法，见w3c，apply类似
也就是用call的提供方法，call里的提供参数，两者结合出结果

全局变量能够通过闭包实现局部（私有）
函数能够访问函数内部定义的所有变量，但是函数也能访问函数外部定义的变量(全局变量)
在网页中，全局变量属于 window 对象。全局变量能够被页面中（以及窗口中）的所有脚本使用和修改
局部变量只能用于其被定义的函数内部。对于其他函数和脚本代码来说它是不可见的。拥有相同名称的全局变量和局部变量是不同的变量。修改一个，不会改变其他
不通过关键词 var 创建的变量总是全局的，即使它们在函数中创建

全局变量活得和您的应用程序（窗口、网页）一样久。局部变量活得不长。它们在函数调用时创建，在函数完成后被删除
在 JavaScript 中，所有函数都有权访问它们“上面”的作用域。JavaScript 支持嵌套函数。嵌套函数可以访问其上的作用域。（多层也可以）
在本例中，内部函数 plus() 可以访问父函数中的 counter 计数器变量：
function add() {
    var counter = 0;
    function plus() {counter += 1;}
    plus();     
    return counter; 
}

var add = (function () {
  var counter = 0;
  return function () {counter += 1; return counter;}
})();

function myFunction(){
  document.getElementById("demo").innerHTML = add();
}
调用函数后，return的是function () {return counter += 1;}
即 document.getElementById("demo").innerHTML = function () {counter += 1; return counter;}
由于是以上类型，于是函数会继续执行（其他的就不一定，如var x = function () {counter += 1; return counter;}; 这时候函数就不会执行，得再次调用才会
执行，x();)
最后的结果为counter为1，这个时候counter=1就变成全局变量了，就可以一直保留和使用
而之后函数内定义的counter随函数结束而消失，最后只有全局变量的counter留下来(因为return只有函数，则counter只能用全局变量counter=1）
这被称为 JavaScript 闭包。它使函数拥有“私有”变量成为可能
闭包指的是有权访问父作用域的函数（上例中是return的函数），即使在父函数关闭之后
csdn有博客收藏

递归优点：省代码  缺点：慢 空间复杂度和时间复杂度很大

暗示全局变量：即任何变量（全局变量和局部变量），如果变量未经声明就赋值，此变量就为全局对象（window)所有
一切声明的全局变量，全是window的属性

js运行三部曲：
语法分析
预编译
解释执行

预编译：（发生在函数执行前一刻）
1、创建AO对象（Activation Object 执行期上下文）
2、找形参和变量声明（var)，将变量和形参名作为AO的属性名，值为undefined（只是挂名，var的变量的值不看，全部是先赋值undefined，重复的只挂一个）
   （只要是在函数A体里的var就算，不管是在if里的、for里的，函数A里有另一个函数B声明（或表达式）里面的var不算，因为那是属于B的AO对象里的成员）
   也就是说只能是第一级的var和函数声明（if、for里的var function（现在不可以function了）是第一级，function里的function和var是下一级了）
3、将实参值和形参统一（把AO对象中的形参名属性的值改为实参传递的值）
4、在函数体里找函数声明，值赋予函数体（将函数声明的函数名作为属性名挂在AO对象上，同样AO如果已有同样的属性名就不用写，然后把函数赋给相应的属性名，
   即function a(){},function b(){}
   原AO{a: undefined}
   则更改后AO{a: function a(){}, b: function b(){}}（记得a要把原来的值改掉）
预编译就是以上四步，结束之后开始执行函数，按照顺序开始执行，进行赋值就要同步更改AO对象中的值，打印的值就是现时根据AO对象中的相应属性值
在函数里打印a会在函数对应的AO对象里找a

不仅执行函数前会预编译，全局（window）也会预编译
全局的预编译和函数预编译不同：1、生成的是GO对象(Global Object)（GO === window） 2、没有形参     
全局预编译结束后，开始从头到尾执行代码，根据具体情况更改GO对象的值，打印的值就是现时根据GO对象中的相应属性值
在全局打印a会在GO对象里找a，GO又名window，因此打印a和打印window.a是一样的

function test(){
    var a = b = 6;
}
b是没有声明就赋值的，因此b是全局变量，是属于GO对象的
test的AO对象里只有a, GO对象里只有b

用一个变量时AO中找不到就找上一层AO，一层一层，最后到GO的（全局变量），找不到就是undefined
但是如果是给变量赋值就不找了，因为暗示性全局变量，就直接变成全局变量，去GO了

在父函数中函数声明（或表达式）的子函数可以访问父函数的变量，但如果子函数B是父函数A调用其他的与父函数无父子关系的函数，B就不可访问A的变量

作用域：
[[scope]]: 每个js函数都是一个对象，对象中有些属性我们可以访问，但有些不可以，这些属性仅供js引擎存取，[[scope]]就是其中一个
[[scope]]就是作用域链，其中存储了运行期上下文的集合

同一个函数每次执行时对应产生的执行上下文都是独一无二的，所以多次调用一个函数时会导致创建多个执行上下文（每一个都是新的，虽然长得一样）
当函数执行完毕后，它所产生的AO会被相应删除，此时该函数的[[scope]]上回到该函数刚被定义的状态

查找变量，从该函数的作用域链的顶端开始找起（即从0开始找起）

一个函数刚出生（被定义的时候），它的作用域链上首先生成其所在生成环境下的对象（有时是GO，有时是上级的AO），然后是再上一级，直到GO
如果一个函数被一层嵌套，则刚出生时他的作用域链（[[scope]]）上，1是GO，0是其父级的AO(多层的从内往外推，最靠近的是第0级）
然后在函数执行之前，会生成自己的AO对象，此时加到自己的[[scope]]上，排号是第0级，原本其他级的级号依次加1
子级的作用域链和父级的作用域链的同名对象是同一个，如B是A的子函数，A的作用域链有A的AO和GO，B定义的时候有A的AO和GO，
这时的B的AO和GO和A的AO和GO指向的是同一个（即B的AO和GO指向的是A的AO和GO）
在B的AO中改变其中的一项a的值，则A访问A中的AO的a时，值也改变了

A函数里定义有函数B，则在定义A的时候，系统只看得到A
（函数A里面写的是什么系统都看不到，只看得到function A(){}),看不到函数B，只有当函数A被执行后（这时候系统才会去解释执行A中的内容），系统才看得到函数B，
这个时候才有函数B的定义
当A函数执行结束后要销毁A的AO，又因为A的AO里有b的函数定义，当A的AO删除后，即A没有执行，此时B的定义也没有了

在函数定义的时候会生成该函数的作用域链，这时只有函数的父级函数的作用域链

立即执行函数（适合做初始化工作）：代码行轮到时马上执行，且执行一次后马上消失，找不到他了(除了立即消失，其他的和普通函数没区别，为了省内存)
格式：(function(a,b,c){}(1,2,3)) 不用写函数名 第一个括号是形参，第二个括号是实参(实参写在执行符号内),参数规则同普通函数
可以有返回值，var num = (function(){}())
另一种写法：(function(){})();
代码块在内存中依然存在，没有删掉，只是没有东西可以指向它（把自己的AO删了，就不会之后的GO中都带着立即函数的AO了，就可以节省空间）

只有表达式才能被执行符号执行：
function test(){}(函数声明） test();(test是表达式，因此可以执行）  表达式：abc,123,345等等都是表达式
function test(){}(); 执行符号()前面的是函数声明，因此不能被执行
var test = function (){}(); 执行符号()前面的是函数表达式，因此可以被执行

加了执行符号就被立即执行，且可执行函数表达式会放弃函数名字（函数被销毁了，原来的指向函数的变量不在指向函数，变成undefined）
var test = function (){}(); （该变量原本引用函数，但立即执行后函数就不存在了，变量引用就不是函数了，这时就变成undefined了）
+ function test(){}(); 有+、-、!三个就会先用Number(); 就会转变成表达式了，执行后test函数就不存在了，test指向undefined
function test(){}(函数声明） test变量指向的是test函数，打印test是函数
（）括起来的就变成表达式了，此时的（）是数学运算符号，不是执行符号
(function(a,b,c){}(1,2,3)) 先执行最外层的括号（数学运算符号），转化成表达式后，再执行(1,2,3)执行符号
(function(){})() 先执行(function(){})转换成表达式，再执行()执行符号

function test(){
   console.log("hh");
}(1,2,3,4);  
不会报错，系统会看成
function test(){
   console.log("hh");
}
(1,2,3,4);（这个是正确语法）（最后的结果是4，即依次执行一次，最后返回最后一个表达式的值）

function test(){
   console.log("hh");
}();会报错，因为()这里的括号只能看成执行符号（有参数的必须得有括号才是立即函数），执行符号前不能是函数声明，得加括号改成立即函数才能通过

同样A函数里定义有函数B，闭包就是在A函数的最后return B; 假设demo = A(); 最后执行后demo = B; 
这时候demo就是函数B了，B仍然有定义，因为在B第一次被定义时，B有了A的AO及GO，A结束之后，A自己销毁自己的AO，
但是B被保存出来了，因此B的作用域链上仍挂着A的AO以及GO，这时候执行demo(),相当于执行B函数，这时创建B的AO，然后如果访问A中的局部变量，B的AO中找不到，
就会往下找A的AO，就找到了

闭包会导致原有作用域链不释放，造成内存泄漏（因为原有作用域链不释放，占用内存，原有的可用的内存少了，即可用的内存变少了，漏了一部分可用的内存出去）
function test(){
   var arr = [];
   for(var i = 0; i < 10; i++){
      arr[i] = function(){（此处的函数并不会执行，只是把函数赋给arr[i]）
            console.log(i + " ");
      }
   }
   return arr;
}
var myArr = test();
for(var j = 0; j < 10; j++){
    myArr[j]();（这时候的myArr[i]上挂的是test的AO和GO和自己创建的AO，这时候test的AO上的i是10，所以就全部打印10
}
最后的结果是：10 10 10 10 10 10 10 10 10 10
现在想要输出0到9：
function test(){
   var arr = [];
   for(var i = 0; i < 10; i++){
     (function(j){
        arr[i] = function(){
            console.log(j + " "); //这时候输出的是j,又因为在定义arr[i] = function这个函数时，前面又定义了一个function(j)函数，因此
        }                           定义arr[i] = function这个函数的作用域链上有GO,test的AO，function(j)的AO，就把j拿到手了
      }(i));                        又因为是立即函数，因此每次function(j)的AO都是新的，j的值也就是不同的了
   return arr;
}
var myArr = test();
for(var j = 0; j < 10; j++){
    myArr[j]();
}

闭包实例：
1、实现共有变量
eg:函数计数器（不依靠外部变量，执行一次函数，计数值加一）
function add(){
     var num;
     function a(){
          console.log(++num);
     }
     return a;
}
var myAdd = add();
myAdd();
myAdd();
执行一次函数，num加一

2、做缓冲结构(保存结果，多个函数可以使用、更改）
（把多个函数返回出来，写对象，对象包含要返回的多个函数）
function test(){
    var food = "apple";
    var obj = {
        eatFood: function(){
            if(food != ""){
               console.log("I am eating " + food);
               food = "";
            }else{
               console.log("There is nothing!");
            }
        }
        pushFood: function(myFood){
            food = myFood;
        }
    }
    return obj;
}
var person = test();
person.eatFood();
person.eatFood();
person.pushFood("banana");
person.eatFood();

