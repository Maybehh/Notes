有tittle就有下划线
dfn 定义项目 定义缩写 斜体
addr 缩写 首字母缩略语
cite 著作的标题 斜体
bdo 文本方向 dir="rtl"
kbd 键盘输入
samp 计算机输出
code 代码 不保留多余的空格和折行
pre 预格式化文本(保留的意思)
var 定义数学变量(公式) 斜体
sup 上标
sub 下标
<!--> 中间可以有标签 
条件注释<!--[if IE 8]>....<![endif]-->只有IE执行的HTML标签(执行里面的内容...)
软件程序标签注释

< a href="(链接)#tips"> 锚 
找不到name就为顶端
链接最后加上斜杠，不然会产生两次访问服务器，第一次加斜杠，第二次访问
链接到邮件时，邮件内容%20制造空格

< img src/>没有结束标签 对齐 align="bottom"默认
left right 为浮动到文本的左右边 源代码中代码顺序不管
img与map配合使用，map中使用area可制作点击图片特定区域进行操作的功能

单元格边距(Cell padding)
单元格间距(Cell spacing)
框架(frame)属性："frame" 属性来控制围绕表格的边框
<table frame="box">
<ol type="a">
<ol start="50">

什么是响应式 Web 设计？
RWD 指的是响应式 Web 设计（Responsive Web Design）
RWD 能够以可变尺寸传递网页
RWD 对于平板和移动设备是必需的
使用 Bootstrap
另一个创建响应式设计的方法，是使用现成的 CSS 框架
Bootstrap 是最流行的开发响应式 web 的 HTML, CSS, 和 JS 框架
Bootstrap 帮助您开发在任何尺寸都外观出众的站点：显示器、笔记本电脑、平板电脑或手机
<meta name="viewport" content="width=device-width, initial-scale=1">

<frameset cols="25%,75%">
   <frame src="frame_a.htm">
   <frame src="frame_b.htm">
</frameset>
不能与 <frameset></frameset> 标签一起使用 <body></body> 标签。不过，如果您需要为不支持框架的浏览器添加一个 <noframes> 标签，
请务必将此标签放置在 <body></body> 标签中！
一个框架有可见边框，用户可以拖动边框来改变它的大小。为了避免这种情况发生，可以在 <frame> 标签中加入：noresize="noresize"
为不支持框架的浏览器添加 <noframes> 标签
<iframe src="demo_iframe.htm" frameborder="0"></iframe>
<iframe src="demo_iframe.htm" name="iframe_a"></iframe>
<p><a href="http://www.w3school.com.cn" target="iframe_a">W3School.com.cn</a></p>

<img src="picture.jpg">	picture.jpg 位于与当前网页相同的文件夹
<img src="images/picture.jpg">	picture.jpg 位于当前文件夹的 images 文件夹中
<img src="/images/picture.jpg">	picture.jpg 当前站点根目录的 images 文件夹中
<img src="../picture.jpg">	picture.jpg 位于当前文件夹的上一级文件夹中

<title> 标签定义文档的标题
title 元素在所有 HTML/XHTML 文档中都是必需的
title 元素能够：
定义浏览器工具栏中的标题
提供页面被添加到收藏夹时显示的标题
显示在搜索引擎结果中的页面标题
<base> 标签为页面上的所有链接规定默认地址（href)或默认目标（target）
<meta> 标签提供关于 HTML 文档的元数据
       name 和 content 属性的作用是描述页面的内容
       
<link>charset 属性规定被链接文档的字符编码方式
      media 属性规定被链接文档将显示在什么设备上
      media 属性用于为不同的媒介类型规定不同的样式
      rel 属性规定当前文档与被链接文档之间的关系(stylesheet文档的外部样式表)
      rev 属性规定被链接文档与当前文档之间的关系
      sizes 属性规定被链接资源的尺寸
            只有当被链接资源是图标时 (rel="icon")，才能使用该属性
            该属性可接受多个值,值由空格分隔
            heightxwidth为被链接的图标规定一个或多个以像素计的高度/宽度值对,高度与宽度之间由 "x" 或 "X" 分隔
            any规定图标是可伸缩的（比如 SVG 图像）
            target _blank在新窗口中打开被链接文档
                   _self	默认。在相同的框架中打开被链接文档
                   _parent	在父框架集中打开被链接文档
                   _top	在整个窗口中打开被链接文档
                   framename	在指定的框架中打开被链接文档
            type 属性规定被链接文档的 MIME 类型
 <meta>name（定义content里的每一个内容的作用）属性提供了名称/值对中的名称
       "keywords" 是一个经常被用到的名称，它为文档定义了一组关键字。某些搜索引擎在遇到这些关键字时，会用这些关键字对文档进行分类
       类似这样的 meta 标签可能对于进入搜索引擎的索引有帮助：
       <meta name="keywords" content="HTML,ASP,PHP,SQL">
       
       http-equiv（发送）属性为名称/值对提供了名称。并指示服务器在发送实际的文档之前先在要传送给浏览器的 MIME 文档头部包含名称/值对
       当服务器向浏览器发送文档时，会先发送许多名称/值对。虽然有些服务器会发送许多这种名称/值对，
       但是所有服务器都至少要发送一个：content-type:text/html。这将告诉浏览器准备接受一个 HTML 文档。
       使用带有 http-equiv 属性的 <meta> 标签时，服务器将把名称/值对添加到发送给浏览器的内容头部。例如，添加：
       <meta http-equiv="charset" content="iso-8859-1">
       <meta http-equiv="expires" content="31 Dec 2008">
       这样发送到浏览器的头部就应该包含：
       content-type: text/html
       charset:iso-8859-1
       expires:31 Dec 2008
       
       content 属性始终要和 name 属性或 http-equiv 属性一起使用
       scheme 属性用于指定要用来翻译属性值的方案。此方案应该在由 <head> 标签的 profile 属性指定的概况文件中进行了定义
       <meta http-equiv="Refresh" content="5;url=http://www.w3school.com.cn" />
<script>
HTML 4 和 XHTML 在处理脚本中的内容方面有所不同：
在 HTML 4 中，内容类型声明为 CDATA，就是说不会对实体进行解析。
在 XHTML 中，内容类型声明为 (#PCDATA)，也就是说会对实体进行解析。
这意味着，在 XHTML 中，应该编码所有特殊的字符，或者把所有内容嵌套在 CDATA 部分中。
为了确保在 XHTML 文档中脚本正确进行解析，请使用如下语法：
<script type="text/javascript"><![CDATA[
  document.write("Hello World!")
//]]></script>
async 属性规定一旦脚本可用，则会异步执行。
注释：async 属性仅适用于外部脚本（只有在使用 src 属性时）。
注释：有多种执行外部脚本的方法：
如果 async="async"：脚本相对于页面的其余部分异步地执行（当页面继续进行解析时，脚本将被执行）
如果不使用 async 且 defer="defer"：脚本将在页面完成解析时执行
如果既不使用 async 也不使用 defer：在浏览器继续解析页面之前，立即读取并执行脚本

defer 属性规定是否对脚本执行进行延迟，直到页面加载为止
有的 javascript 脚本 document.write 方法来创建当前的文档内容，其他脚本就不一定是了
如果您的脚本不会改变文档的内容，可将 defer 属性加入到 <script> 标签中，以便加快处理文档的速度。
因为浏览器知道它将能够安全地读取文档的剩余部分而不用执行脚本，它将推迟对脚本的解释，直到文档已经显示给用户为止

<style> 标签用于为 HTML 文档定义样式信息
在 style 中，您可以规定在浏览器中如何呈现 HTML 文档
type 属性是必需的，定义 style 元素的内容。唯一可能的值是 "text/css"
style 元素位于 head 部分中
media 属性用于为不同的媒介类型规定不同的样式
提示：如需在一个 style 元素中定义一个以上的媒介类型，请使用逗号分隔的列表（例如：<style type="text/css" media="screen,projection">）
<html>
<head>
<style type="text/css">
h1 {color:#FF0000;}
p {color:#0000FF;}
body {background-color:#FFEFD6;}
</style>

<style type="text/css" media="print">
h1 {color:#000000;}
p {color:#000000;}
body {background-color:#FFFFFF;}
</style>
</head>

<body>
<h1>Header 1</h1>
<p>A paragraph.</p>
</body>
</html>

URL 可以由单词组成，比如 “w3school.com.cn”，或者是因特网协议（IP）地址：192.168.1.253
scheme://host.domain:port/path/filename
解释：
scheme - 定义因特网服务的类型。最常见的类型是 http
host - 定义域主机（http 的默认主机是 www）
domain - 定义因特网域名，比如 w3school.com.cn
:port - 定义主机上的端口号（http 的默认端口号是 80）
path - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。
filename - 定义文档/资源的名称
编者注：URL 的英文全称是 Uniform Resource Locator，中文也译为“统一资源定位符”

http	超文本传输协议	以 http:// 开头的普通网页。不加密。
https	安全超文本传输协议	安全网页。加密所有信息交换。
ftp	文件传输协议	用于将文件下载或上传至网站。
file	您计算机上的文件

URL 编码使用 "%" 其后跟随两位的十六进制数来替换非 ASCII 字符。
URL 不能包含空格。URL 编码通常使用 + 来替换空格

如果希望向世界发布您的网站，那么您必须把它存放在 web 服务器上
使用因特网服务提供商（ISP）

<!DOCTYPE> 声明帮助浏览器正确地显示网页
<!DOCTYPE> 不是 HTML 标签。它为浏览器提供一项信息（声明），即 HTML 是用什么版本编写的

&lt; is the same as <
&gt; is the same as >
&#169; is the same as ©

XHTML 指的是可扩展超文本标记语言
XHTML 是以 XML 应用的方式定义的 HTML
文档结构
XHTML DOCTYPE 是强制性的（DOCTYPE 没有关闭标签）
<html> 中的 XML namespace 属性是强制性的
<html>、<head>、<title> 以及 <body> 也是强制性的
元素语法
XHTML 元素必须正确嵌套
XHTML 元素必须始终关闭
XHTML 元素必须小写
XHTML 文档必须有一个根元素
属性语法
XHTML 属性必须使用小写
XHTML 属性值必须用引号包围
XHTML 属性最小化也是禁止的（属性简写）<input checked>错误 <input checked="checked" />正确

如何从 HTML 转换到 XHTML
向每张页面的第一行添加 XHTML <!DOCTYPE>
向每张页面的 html 元素添加 xmlns 属性，例如：<html xmlns="http://www.w3.org/1999/xhtml">
把所有元素名改为小写
关闭所有空元素
把所有属性名改为小写
为所有属性值加引号
文档类型定义（DTD）可定义合法的XML文档构建模块。它使用一系列合法的元素来定义文档的结构
通过 DTD，您的每一个 XML 文件均可携带一个有关其自身格式的描述。
通过 DTD，独立的团体可一致地使用某个标准的 DTD 来交换数据。
而您的应用程序也可使用某个标准的 DTD 来验证从外部接收到的数据。
您还可以使用 DTD 来验证您自身的数据
在 XHTML 中有哪些不同的 DTD ？ Strict, Transitional, Frameset
Transitional是最常用的 XHTML DTD

<input type="submit"> 定义用于向表单处理程序（form-handler）提交表单的按钮。
表单处理程序通常是包含用来处理输入数据的脚本的服务器页面。
表单处理程序在表单的 action 属性中指定：
实例
<form action="action_page.php">
First name:<br>
<input type="text" name="firstname" value="Mickey">
<br>
Last name:<br>
<input type="text" name="lastname" value="Mouse">
<br><br>
<input type="submit" value="Submit">
</form> 
Action 属性
action 属性定义在提交表单时执行的动作
向服务器提交表单的通常做法是使用提交按钮
通常，表单会被提交到 web 服务器上的网页
在上面的例子中，指定了某个服务器脚本来处理被提交表单：
<form action="action_page.php">
如果省略 action 属性，则 action 会被设置为当前页面

method 属性规定在提交表单时所用的 HTTP 方法（GET 或 POST）
您能够使用 GET（默认方法）：
如果表单提交是被动的（比如搜索引擎查询），并且没有敏感信息。
当您使用 GET 时，表单数据在页面地址栏中是可见的：
action_page.php?firstname=Mickey&lastname=Mouse
注释：GET 最适合少量数据的提交。浏览器会设定容量限制。

如果表单正在更新数据，或者包含敏感信息（例如密码）
POST 的安全性更加，因为在页面地址栏中被提交的数据是不可见的

Name 属性
如果要正确地被提交，每个输入字段必须设置一个 name 属性

用 <fieldset> 组合表单数据
<fieldset> 元素组合表单中的相关数据
<legend> 元素为 <fieldset> 元素定义标题
实例
<form action="action_page.php">
<fieldset>
<legend>Personal information:</legend>
First name:<br>
<input type="text" name="firstname" value="Mickey">
<br>
Last name:<br>
<input type="text" name="lastname" value="Mouse">
<br><br>
<input type="submit" value="Submit"></fieldset>
</form> 

下面是 <form> 属性的列表：
accept-charset	规定在被提交表单中使用的字符集（默认：页面字符集）。
action	规定向何处提交表单的地址（URL）（提交页面）。
autocomplete	规定浏览器应该自动完成表单（默认：开启）。
enctype	规定被提交数据的编码（默认：url-encoded）。
method	规定在提交表单时所用的 HTTP 方法（默认：GET）。
name	规定识别表单的名称（对于 DOM 使用：document.forms.name）。
novalidate	规定浏览器不验证表单。
target	规定 action 属性中地址的目标（默认：_self）

<select name="cars">
<option value="volvo" selected="selected">Volvo</option>
<option value="saab">Saab</option>
<option value="fiat">Fiat</option>
<option value="audi">Audi</option>
</select>

<textarea name="message" rows="10" cols="30">
The cat was playing in the garden.
</textarea>

<button type="button" onclick="alert('Hello World!')">Click Me!</button>

<datalist> 元素为 <input> 元素规定预定义选项列表。
用户会在他们输入数据时看到预定义选项的下拉列表。
<input> 元素的 list 属性必须引用 <datalist> 元素的 id 属性。
实例
通过 <datalist> 设置预定义值的 <input> 元素：
<form action="action_page.php">
<input list="browsers">
<datalist id="browsers">
   <option value="Internet Explorer">
   <option value="Firefox">
   <option value="Chrome">
   <option value="Opera">
   <option value="Safari">
</datalist> 
</form>

<input type="text"> 定义供文本输入的单行输入字段
<input type="password"> 定义密码字段 注释：password 字段中的字符会被做掩码处理（显示为星号或实心圆）
<input type="submit" value="Submit"(按钮上的文字）> 定义提交表单数据至表单处理程序的按钮
<input type="radio" name="sex" value="male"（按钮上的文字） checked>单选按钮
<input type="checkbox" name="vehicle" value="Bike"（按钮上的文字）>复选框
<input type="button> 定义按钮
<input type="number"> 用于应该包含数字值的输入字段,您能够对数字做出限制,根据浏览器支持，限制可应用到输入字段
                      <input type="number" name="quantity" min="1" max="5">
                      
输入限制
这里列出了一些常用的输入限制（其中一些是 HTML5 中新增的）：
disabled	规定输入字段应该被禁用。
max	规定输入字段的最大值。
maxlength	规定输入字段的最大字符数。
min	规定输入字段的最小值。
pattern	规定通过其检查输入值的正则表达式。
readonly	规定输入字段为只读（无法修改）。
required	规定输入字段是必需的（必需填写）。
size	规定输入字段的宽度（以字符计）。
step	规定输入字段的合法数字间隔。
value	规定输入字段的默认值
例：<input type="number" name="points" min="0" max="100" step="10" value="30">

<input type="date"> 用于应该包含日期的输入字段
根据浏览器支持，日期选择器会出现输入字段中
<input type="date" name="bday" max="1979-12-31">
<input type="date" name="bday" min="2000-01-02">

<input type="color"> 用于应该包含颜色的输入字段
根据浏览器支持，颜色选择器会出现输入字段中

<input type="range"> 用于应该包含一定范围内的值的输入字段
根据浏览器支持，输入字段能够显示为滑块控件
<input type="range" name="points" min="0" max="10">

<input type="month"> 允许用户选择月份和年份
根据浏览器支持，日期选择器会出现输入字段中

<input type="week"> 允许用户选择周和年
根据浏览器支持，日期选择器会出现输入字段中

<input type="time"> 允许用户选择时间（无时区）
根据浏览器支持，时间选择器会出现输入字段中

<input type="datetime"> 允许用户选择日期和时间（有时区）
根据浏览器支持，日期选择器会出现输入字段中

<input type="datetime-local"> 允许用户选择日期和时间（无时区）
根据浏览器支持，日期选择器会出现输入字段中

<input type="email"> 用于应该包含电子邮件地址的输入字段
根据浏览器支持，能够在被提交时自动对电子邮件地址进行验证
某些智能手机会识别 email 类型，并在键盘增加 ".com" 以匹配电子邮件输入

<input type="search"> 用于搜索字段（搜索字段的表现类似常规文本字段）

<input type="tel"> 用于应该包含电话号码的输入字段

<input type="url"> 用于应该包含 URL 地址的输入字段
根据浏览器支持，在提交时能够自动验证 url 字段
某些智能手机识别 url 类型，并向键盘添加 ".com" 以匹配 url 输入

readonly 属性规定输入字段为只读（不能修改）
<input type="text" name="firstname" value="John" readonly>
readonly 属性不需要值。它等同于 readonly="readonly"

novalidate 属性属于 <form> 属性
如果设置，则 novalidate 规定在提交表单时不对表单数据进行验证

autofocus 属性是布尔属性
如果设置，则规定当页面加载时 <input> 元素应该自动获得焦点

form 属性规定 <input> 元素所属的一个或多个表单
提示：如需引用一个以上的表单，请使用空格分隔的表单 id 列表
实例
输入字段位于 HTML 表单之外（但仍属表单）：
<form action="action_page.php" id="form1">
   First name: <input type="text" name="fname"><br>
   <input type="submit" value="Submit">
</form>
Last name: <input type="text" name="lname" form="form1">

formaction 属性规定当提交表单时处理该输入控件的文件的 URL
formaction 属性覆盖 <form> 元素的 action 属性
formaction 属性适用于 type="submit" 以及 type="image"
<form action="action_page.php">
   First name: <input type="text" name="fname"><br>
   Last name: <input type="text" name="lname"><br>
   <input type="submit" value="Submit"><br>
   <input type="submit" formaction="demo_admin.asp"
   value="Submit as admin">
</form> 

formenctype 属性规定当把表单数据（form-data）提交至服务器时如何对其进行编码（仅针对 method="post" 的表单）
formenctype 属性覆盖 <form> 元素的 enctype 属性
formenctype 属性适用于 type="submit" 以及 type="image"

formmethod 属性定义用以向 action URL 发送表单数据（form-data）的 HTTP 方法
formmethod 属性覆盖 <form> 元素的 method 属性
formmethod 属性适用于 type="submit" 以及 type="image"

formnovalidate 属性覆盖 <form> 元素的 novalidate 属性
formnovalidate 属性可用于 type="submit"
拥有两个提交按钮的表单（验证和不验证）：
<form action="action_page.php">
   E-mail: <input type="email" name="userid"><br>
   <input type="submit" value="Submit"><br>
   <input type="submit" formnovalidate value="Submit without validation">
</form> 

formtarget 属性规定的名称或关键词指示提交表单后在何处显示接收到的响应
formtarget 属性会覆盖 <form> 元素的 target 属性
formtarget 属性可与 type="submit" 和 type="image" 使用

height 和 width 属性规定 <input> 元素的高度和宽度
height 和 width 属性仅用于 <input type="image">

list 属性引用的 <datalist> 元素中包含了 <input> 元素的预定义选项

min 和 max 属性规定 <input> 元素的最小值和最大值
min 和 max 属性适用于如需输入类型：number、range、date、datetime、datetime-local、month、time 以及 week

multiple 属性是布尔属性
如果设置，则规定允许用户在 <input> 元素中输入一个以上的值
multiple 属性适用于以下输入类型：email 和 file
接受多个值的文件上传字段
<input type="file" name="img" multiple="multiple" />

pattern 属性规定用于检查 <input> 元素值的正则表达式
pattern 属性适用于以下输入类型：text、search、url、tel、email、and password
提示：请使用全局的 title 属性对模式进行描述以帮助用户(输入框提示title的内容）
<input type="text" name="country_code" pattern="[A-z]{3}" title="三个字母的国家代码" />

placeholder 属性规定用以描述输入字段预期值的提示（样本值或有关格式的简短描述）
该提示会在用户输入值之前显示在输入字段中
placeholder 属性适用于以下输入类型：text、search、url、tel、email 以及 password

required 属性是布尔属性
如果设置，则规定在提交表单之前必须填写输入字段
required 属性适用于以下输入类型：text、search、url、tel、email、password、date pickers、number、checkbox、radio、and file

step 属性规定 <input> 元素的合法数字间隔
示例：如果 step="3"，则合法数字应该是 -3、0、3、6、等等
提示：step 属性可与 max 以及 min 属性一同使用，来创建合法值的范围
step 属性适用于以下输入类型：number、range、date、datetime、datetime-local、month、time 以及 week

HTML5 是专门为承载丰富的 web 内容而设计的，并且无需额外插件

HTML5 定义了八个新的语义 HTML 元素。所有都是块级元素
您可以把 CSS display 属性设置为 block，以确保老式浏览器中正确的行为:
header, section, footer, aside, nav, main, article, figure {
    display: block; 
}

向 HTML 添加新元素
您可以通过浏览器 trick 向 HTML 添加任何新元素：
本例向 HTML 添加了一个名为 <myHero> 的新元素，并为其定义 display 样式：
<script>document.createElement("myHero")</script>(已添加的JavaScript语句document.createElement("myHero")，仅适用于IE(IE需要，其他的直接写）)
<style>
  myHero {
    display: block;
    background-color: #ddd;
    padding: 50px;
    font-size: 30px;
  } 
</style> 
<myHero>My First Hero</myHero>

上述方案可用于所有新的 HTML5 元素，但是：
注意：Internet Explorer 8 以及更早的版本，不允许对未知元素添加样式
幸运的是，Sjoerd Visscher 创造了 "HTML5 Enabling JavaScript", "the shiv"：
<!--[if lt IE 9]>
  <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
以上代码是一段注释，但是 IE9 的早期版本会读取它（并理解它）

完整的 Shiv 解决方案
<!DOCTYPE html>
<html>
<head>
  <title>Styling HTML5</title>
  <!--[if lt IE 9]>
  <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
</head>
<body>
<h1>My First Article</h1>
<article>
London is the capital city of England. 
It is the most populous city in the United Kingdom, 
with a metropolitan area of over 13 million inhabitants.
</article>
</body>
</html>
引用 shiv 代码的链接必须位于 <head> 元素中，因为 Internet Explorer 需要在读取之前认识所有新元素

语义元素清楚地向浏览器和开发者描述其意义
非语义元素的例子：<div> 和 <span> - 无法提供关于其内容的信息
语义元素的例子：<form>、<table> 以及 <img> - 清晰地定义其内容

<section> 元素定义文档中的节
根据 W3C 的 HTML 文献：“节（section）是有主题的内容组，通常具有标题”
可以将网站首页划分为简介、内容、联系信息等节

在 HTML5 标准中，<article> 元素定义完整的相关元素自包含块
<section> 元素被定义为相关元素块
我们能够使用该定义来决定如何嵌套元素吗？不，我们不能！

<header> 元素为文档或节规定页眉
<header> 元素应该被用作介绍性内容的容器
一个文档中可以有多个 <header> 元素

<footer> 元素为文档或节规定页脚
<footer> 元素应该提供有关其包含元素的信息
页脚通常包含文档的作者、版权信息、使用条款链接、联系信息等等
您可以在一个文档中使用多个 <footer> 元素

<nav> 元素定义导航链接集合
<nav> 元素旨在定义大型的导航链接块。不过，并非文档中所有链接都应该位于 <nav> 元素中！

<aside> 元素页面主内容之外的某些内容（比如侧栏）
aside 内容应该与周围内容相关

在书籍和报纸中，与图片搭配的标题很常见
标题（caption）的作用是为图片添加可见的解释
通过 HTML5，图片和标题能够被组合在 <figure> 元素中：
实例
<figure>
   <img src="pic_mountain.jpg" alt="The Pulpit Rock" width="304" height="228">
   <figcaption>Fig1. - The Pulpit Pock, Norway.</figcaption>
</figure> （位置按代码顺序）
<img> 元素定义图像，<figcaption> 元素定义标题。

为何使用 HTML5 元素？
根据 W3C，语义网：
“允许跨应用程序、企业和团体对数据进行分享和重用。”（统一属性名）

<main>	规定文档的主内容
<mark>	定义重要的或强调的文本
<details>	定义用户能够查看或隐藏的额外细节
<summary>	定义 <details> 元素的可见标题
<time>	定义日期/时间

<div id="menu">	<nav>
<div id="content">	<section>
<div id="post">	<article>
HTML5 doctype：<!DOCTYPE html>
修改编码信息，从 HTML4：
<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
改为 HTML5：
<meta charset="utf-8">
在 HTML5 标准中，<article> <section> 与 <div> 之间的差异很小，令人困惑
在 HTML5 标准中，<section> 元素被定位为相关元素的块
<article> 元素被定义为相关元素的完整的自包含块
<div> 元素被定义为子元素的块

html5
请始终对图像使用 alt 属性,当图像无法显示时该属性很重要
请始终定义图像尺寸。这样做会减少闪烁，因为浏览器会在图像加载之前为图像预留空间
在 HTML5 标准中，<head> 标签也能够被省略
默认地，浏览器会把 <body> 之前的所有元素添加到默认的 <head> 元素
通过省略 <head> 标签，您能够降低 HTML 的复杂性
短注释应该在单行中书写，并在 <!-- 之后增加一个空格，在 <!-- 之前增加一个空格：
<!-- This is a comment -->
长注释，跨越多行，应该通过 <!-- 和 --> 在独立的行中书写：
<!-- 
  This is a long comment example. This is a long comment example. This is a long comment example.
  This is a long comment example. This is a long comment example. This is a long comment example.
-->
长注释更易观察，如果它们被缩进两个空格的话
只在值包含空格时使用引号来包围值（css)

canvas 元素本身是没有绘图能力的。所有的绘制工作必须在 JavaScript 内部完成
JavaScript 使用 id 来寻找 canvas 元素：
var c=document.getElementById("myCanvas");
然后，创建 context 对象：
var cxt=c.getContext("2d"); 
getContext("2d") 对象是内建的 HTML5 对象，拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法

<canvas> 标签定义图形，比如图表和其他图像
<canvas> 标签只是图形容器，您必须使用脚本来绘制图形

每当画布的高度或宽度被重设时，画布内容就会被清空
<canvas> 标记和 SVG 以及 VML 之间的差异
<canvas> 标记和 SVG 以及 VML 之间的一个重要的不同是，<canvas> 有一个基于 JavaScript 的绘图 API，而 SVG 和 VML 使用一个 XML 文档来描述绘图
这两种方式在功能上是等同的，任何一种都可以用另一种来模拟。从表面上看，它们很不相同，可是，每一种都有强项和弱点。
例如，SVG 绘图很容易编辑，只要从其描述中移除元素就行。
要从同一图形的一个 <canvas> 标记中移除元素，往往需要擦掉绘图重新绘制它

Canvas.getContext(contextID)
参数 contextID 指定了您想要在画布上绘制的类型。当前唯一的合法值是 "2d"，它指定了二维绘图，并且导致这个方法返回一个环境对象，该对象导出一个二维绘图API
返回一个表示用来绘制的环境类型的环境。其本意是要为不同的绘制类型（2 维、3 维）提供不同的环境。
当前，唯一支持的是 "2d"，它返回一个 CanvasRenderingContext2D 对象，该对象实现了一个画布所使用的大多数方法

Canvas API 也使用了路径的表示法。但是，路径由一系列的方法调用来定义，而不是描述为字母和数字的字符串，比如调用 beginPath() 和 arc() 方法
一旦定义了路径，其他的方法，如 fill()，都是对此路径操作。绘图环境的各种属性，比如 fillStyle，说明了这些操作如何使用
Canvas API 非常紧凑的一个原因上它没有对绘制文本提供任何支持。要把文本加入到一个 <canvas> 图形，
必须要么自己绘制它再用位图图像合并它，或者在 <canvas> 上方使用 CSS 定位来覆盖 HTML 文本

CanvasRenderingContext2D 对象提供了一组用来在画布上绘制的图形函数：
strokeRect() 方法用于在单选按钮上模拟一次鼠标点击
stroke() 方法绘制当前路径的边框

lineCap 属性指定线段的末端如何绘制
lineJoin 属性说明如何绘制交点
miterLimit 属性说明如何绘制交点（当一个斜角连接超过了 miterLimit，连接会转换为圆连接）
   当宽线条使用设置为 "miter" 的 lineJoin 属性绘制并且两条线段以锐角相交的时候，所得的斜面可能相当长。
   当斜面太长，就会变得不协调。miterLimit 属性为斜面的长度设置一个上限。这个属性表示斜面长度和线条长度的比值。
   默认是 10，意味着一个斜面的长度不应该超过线条宽度的 10 倍。如果斜面达到这个长度，它就变成斜角了
   当 lineJoin 为 "round" 或 "bevel" 的时候，这个属性无效
beginPath() 丢弃任何当前定义的路径并且开始一条新的路径。它把当前的点设置为 (0,0)
当一个画布的环境第一次创建，beginPath() 方法会被显式地调用

如果画布的子路径是打开的，closePath() 通过添加一条线条连接当前点和子路径起始点来关闭它
如果子路径已经闭合了，这个方法不做任何事情
一旦子路径闭合，就不能再为其添加更多的直线或曲线了。要继续向该路径添加，需要通过调用 moveTo() 开始一条新的子路径
不需要在勾勒或填充一条路径之前调用 closePath()。当填充的时候（并且当你调用 clip() 的时候），路径是隐式闭合的

fill() 方法使用 fillStyle 属性所指定的颜色、渐变和模式来填充当前路径。这一路径的每一条子路径都单独填充。
任何未闭合的子路径都被填充，就好像已经对他们调用了 closePath() 方法一样（但是，注意，实际上没有这么让子路径成为闭合的）

rect() 方法为路径添加了一个矩形。这个矩形是路径的一个子路径并且没有和路径中的任何其他子路径相连，当 rect() 方法返回时，当前位置是 (0,0)

clearRect() 方法擦除了指定的矩形，并且用一个透明的颜色填充它

drawImage(image, sourceX, sourceY, sourceWidth, sourceHeight,destX, destY, destWidth, destHeight)
image所要绘制的图像,这必须是表示 <img> 标记或者屏幕外图像的 Image 对象，或者是 Canvas 元素
x, y	要绘制的图像的左上角的位置
width, height	图像所应该绘制的尺寸。指定这些参数使得图像可以缩放
sourceX, sourceY	图像将要被绘制的区域的左上角。这些整数参数用图像像素来度量
sourceWidth, sourceHeight	图像所要绘制区域的大小，用图像像素表示
destX, destY	所要绘制的图像区域的左上角的画布坐标
destWidth, destHeight	图像区域所要绘制的画布大小

addColorStop() 方法在渐变中的某一点添加一个颜色变化
createLinearGradient() 方法创建一条线性颜色渐变
createRadialGradient() 方法创建一条放射颜色渐变

当没有设置宽度和高度的时候，canvas会初始化宽度为300像素和高度为150像素。该元素可以使用CSS来定义大小，但在绘制时图像会伸缩以适应它的框架尺寸：
如果CSS的尺寸与初始画布的比例不一致，它会出现扭曲。
注意: 如果你绘制出来的图像是扭曲的, 尝试用width和height属性为<canvas>明确规定宽高，而不是使用CSS

canvas默认坐标系下，坐标值为负的话，不在画布范围内，不显示

这非常简单：我们只是在<canvas>标签中提供了替换内容。不支持<canvas>的浏览器将会忽略容器并在其中渲染后备内容。
而支持<canvas>的浏览器将会忽略在容器中包含的内容，并且只是正常渲染canvas（不支持的执行canvas中的内容，支持的执行js中的内容）

</canvas> 标签不可省，如果结束标签不存在，则文档的其余部分会被认为是替代内容，将不会显示出来（文档剩余所有的都不会显示）
如果不需要替代内容，一个简单的 <canvas id="foo" ...></canvas> 在所有支持canvas的浏览器中都是完全兼容的

检查支持性
替换内容是用于在不支持 <canvas> 标签的浏览器中展示的。通过简单的测试getContext()方法的存在，脚本可以检查编程支持性。上面的代码片段现在变成了这个样子：
var canvas = document.getElementById('tutorial');
if (canvas.getContext){
  var ctx = canvas.getContext('2d');
  // drawing code here
} else {
  // canvas-unsupported code here
}

不同于 SVG，<canvas> 只支持两种形式的图形绘制：矩形和路径

生成路径的第一步叫做beginPath()。本质上，路径是由很多子路径构成，这些子路径都是在一个列表中，
所有的子路径（线、弧形、等等）构成图形。而每次这个方法调用之后，列表清空重置，然后我们就可以重新绘制新的图形
注意：当前路径为空，即调用beginPath()之后，或者canvas刚建的时候，
第一条路径构造命令通常被视为是moveTo（），无论实际上是什么。出于这个原因，你几乎总是要在设置路径之后专门指定你的起始位置
闭合路径closePath(),不是必需的。这个方法会通过绘制一条从当前点到开始点的直线来闭合图形。如果图形是已经闭合了的，即当前点为开始点，该函数什么也不做
注意：当你调用fill()函数时，所有没有闭合的形状都会自动闭合，所以你不需要调用closePath()函数。但是调用stroke()时不会自动闭合

arc(x, y, radius, startAngle, endAngle, anticlockwise)（参数anticlockwise为一个布尔值，为true时，是逆时针方向，否则顺时针方向）
注意：arc()函数中表示角的单位是弧度，不是角度。角度与弧度的js表达式:
弧度=(Math.PI/180)*角度

quadraticCurveTo(cp1x, cp1y, x, y)
绘制二次贝塞尔曲线，cp1x,cp1y为一个控制点，x,y为结束点。
bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)
绘制三次贝塞尔曲线，cp1x,cp1y为控制点一，cp2x,cp2y为控制点二，x,y为结束点

二次贝塞尔曲线有一个开始点（蓝色）、一个结束点（蓝色）以及一个控制点（红色），而三次贝塞尔曲线有两个控制点
参数x、y在这两个方法中都是结束点坐标。cp1x,cp1y为坐标中的第一个控制点，cp2x,cp2y为坐标中的第二个控制点

rect(x, y, width, height)
绘制一个左上角坐标为（x,y），宽高为width以及height的矩形。
当该方法执行的时候，moveTo()方法自动设置坐标参数（0,0）。也就是说，当前笔触自动重置回默认坐标

为了简化代码和提高性能，Path2D对象已可以在较新版本的浏览器中使用，用来缓存或记录绘画命令，这样你将能快速地回顾路径,例：
function draw() {
  var canvas = document.getElementById('canvas');
  if (canvas.getContext){
    var ctx = canvas.getContext('2d');

    var rectangle = new Path2D();
    rectangle.rect(10, 10, 50, 50);

    var circle = new Path2D();
    circle.moveTo(125, 35);
    circle.arc(100, 35, 25, 0, 2 * Math.PI);

    ctx.stroke(rectangle);
    ctx.fill(circle);
  }
}
新的Path2D API有另一个强大的特点，就是使用SVG path data来初始化canvas上的路径。这将使你获取路径时可以以SVG或canvas的方式来重用它们，例：
var p = new Path2D("M10 10 h 80 v 80 h -80 Z");
ctx.fill(p);

fillStyle = color设置图形的填充颜色   strokeStyle = color设置图形轮廓的颜色

miterLimit = value限制当两条线相交时交接处最大长度；所谓交接处长度（斜接长度）是指线条交接处内角顶点到外角顶点的长度
lineWidth线宽是指给定路径的中心到两边的粗细。换句话说就是在路径的两边各绘制线宽的一半
实际填充区域（深蓝色部分）仅仅延伸至路径两旁各一半像素。而这半个像素又会以近似的方式进行渲染，这意味着那些像素只是部分着色，
结果就是以实际笔触颜色一半色调的颜色来填充整个区域（浅蓝和深蓝的部分）

线段的外侧边缘会延伸交汇于一点上。线段直接夹角比较大的，交点不会太远，但当夹角减少时，交点距离会呈指数级增大
miterLimit 属性就是用来设定外延交点与连接点的最大距离，如果交点距离大于此值，连接效果会变成了 bevel


用 setLineDash 方法和 lineDashOffset 属性来制定虚线样式.
setLineDash 方法接受一个数组(实线长度和空隙长度），来指定线段与间隙的交替；（ctx.setLineDash([4, 2]);）
lineDashOffset 属性设置起始偏移量

createLinearGradient(x1, y1, x2, y2)
createLinearGradient 方法接受 4 个参数，表示渐变的起点 (x1,y1) 与终点 (x2,y2)
createRadialGradient(x1, y1, r1, x2, y2, r2)
createRadialGradient 方法接受 6 个参数，前三个定义一个以 (x1,y1) 为原点，半径为 r1 的圆，后三个参数则定义另一个以 (x2,y2) 为原点，半径为 r2 的圆
（两个圆半径之间的渐变，内圆内的为最后或开始的颜色，外圆外的为最后或开始的颜色）
gradient.addColorStop(position, color)
addColorStop 方法接受 2 个参数，position 参数必须是一个 0.0 与 1.0 之间的数值，表示渐变中颜色所在的相对位置
例如，0.5 表示颜色会出现在正中间。color 参数必须是一个有效的 CSS 颜色值（如 #FFF， rgba(0,0,0,1)，等等）

createPattern(image, type)
该方法接受两个参数。Image 可以是一个 Image 对象的引用，或者另一个 canvas 对象。Type 必须是下面的字符串值之一：repeat，repeat-x，repeat-y和no-repeat
var img = new Image();
img.src = 'someimage.png';
var ptrn = ctx.createPattern(img,'repeat');
注意：与 drawImage 有点不同，你需要确认 image 对象已经装载完毕，否则图案可能效果不对的
使用 Image 对象的 onload handler 来确保设置图案之前图像已经装载完毕
function draw() {
  var ctx = document.getElementById('canvas').getContext('2d');

  // 创建新 image 对象，用作图案
  var img = new Image();
  img.src = 'https://mdn.mozillademos.org/files/222/Canvas_createpattern.png';
  img.onload = function() {

    // 创建图案
    var ptrn = ctx.createPattern(img, 'repeat');
    ctx.fillStyle = ptrn;
    ctx.fillRect(0, 0, 150, 150);

  }
}

shadowOffsetX（Y) = float负值表示阴影会往上或左延伸，正值则表示会往下或右延伸，它们默认都为0
shadowBlur 用于设定阴影的模糊程度 shadowColor = color

Canvas 填充规则
fill（或者 clip和isPointinPath ）   例：ctx.fill("evenodd");
"nonzero": non-zero winding rule, 默认值.
"evenodd":  even-odd winding rule

fillText(text, x, y [, maxWidth])
在指定的(x,y)位置填充指定的文本，绘制的最大宽度是可选的.
strokeText(text, x, y [, maxWidth])
在指定的(x,y)位置绘制文本边框，绘制的最大宽度是可选的
font = value  默认的字体是 10px sans-serif
textAlign = value 文本对齐选项
textBaseline = value 基线对齐选项
获得文本细节：measureText()将返回一个 TextMetrics对象的宽度、所在像素，这些体现文本特性的属性，例：
下面的代码段将展示如何测量文本来获得它的宽度：
function draw() {
  var ctx = document.getElementById('canvas').getContext('2d');
  var text = ctx.measureText("foo"); // TextMetrics object
  text.width; // 16;
}

获得图片：
HTMLImageElement
这些图片是由Image()函数构造出来的，或者任何的<img>元素
HTMLVideoElement
用一个HTML的 <video>元素作为你的图片源，可以从视频中抓取当前帧作为一个图像
HTMLCanvasElement
可以使用另一个 <canvas> 元素作为你的图片源。
ImageBitmap
这是一个高性能的位图，可以低延迟地绘制，它可以从上述的所有源以及其它几种源中生成

使用相同页面内的图片
document.images集合
document.getElementsByTagName()方法
document.getElementById()方法
使用其它域名下的图片
在 HTMLImageElement上使用crossOrigin属性，你可以请求加载其它域名上的图片。
如果图片的服务器允许跨域访问这个图片，那么你可以使用这个图片而不污染canvas，否则，使用这个图片将会污染canvas（在 <canvas> 检索数据过程中引发异常）

由零开始创建图像
若调用 drawImage 时，图片没装载完，那什么都不会发生（在一些旧的浏览器中可能会抛出异常）。因此你应该用load事件来保证不会在加载完毕之前使用这个图片：
var img = new Image();   // 创建img元素
img.onload = function(){（加载后调用函数）
  // 执行drawImage语句
}
img.src = 'myImage.png'; // 设置图片源地址

通过 data: url 方式嵌入图像：
我们还可以通过 data:url 方式来引用图像。Data urls 允许用一串 Base64 编码的字符串的方式来定义一个图片。
img.src = 'data:image/gif;base64,R0lGODlhCwALAIAAAAAA3pn/ZiH5BAEAAAEALAAAAAALAAsAAAIUhA+hkcuO4lmNVindo7qyrIXiGBYAOw==';
其优点就是图片内容即时可用，无须再到服务器兜一圈。（还有一个优点是，可以将 CSS，JavaScript，HTML 和 图片全部封装在一起，迁移起来十分方便。）
缺点就是图像没法缓存，图片大的话内嵌的 url 数据会相当的长

绘制图片：
一旦获得了源图对象，我们就可以使用 drawImage 方法将它渲染到 canvas 里
缩放 Scaling：
drawImage(image, x, y, width, height)这个方法多了2个参数：width 和 height，
这两个参数用来控制 当向canvas画入时应该缩放的大小（以width和height显示）
切片 Slicing：
drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)
第一个参数和其它的是相同的，都是一个图像或者另一个 canvas 的引用
其它8个参数最好是参照右边的图解，前4个是定义图像源的切片位置和大小，后4个则是定义切片的目标显示位置和大小
24-bit PNG 图像带有一个完整的 8-bit alpha 通道，与 GIF 和 8-bit PNG 不同，我可以将它放成背景而不必担心底色的问题

控制图像的缩放行为 Controlling image scaling behavior
Gecko 1.9.2 引入了 mozImageSmoothingEnabled 属性，值为 false 时，图像不会平滑地缩放。默认是 true 

每一次调用 restore （画布(canvas)的所有状态）方法，上一个保存的状态就从栈中弹出，所有设定都恢复
translate(x, y)（移动原点）
rotate(angle)（以原点为中心旋转 canvas）：
这个方法只接受一个参数：旋转的角度(angle)，它是顺时针方向的，以弧度为单位的值。
旋转的中心点始终是 canvas 的原点，如果要改变它，我们需要用到 translate 方法
scale(x, y)
scale  方法可以缩放画布的水平和垂直的单位。两个参数都是实数，可以为负数，x 为水平缩放因子，y 为垂直缩放因子，如果比1小，会比缩放图形， 
如果比1大会放大图形。默认值为1， 为实际大小。
（坐标轴，画布位置均不变，进行坐标轴变换，负数坐标轴180翻转缩放（正轴变负轴，原点位置不动），在现在的坐标轴按坐标作画，画完后，
看scale(x,y),x为负则左右翻转，y为负则上下翻转，翻转后的内容为最后显示的内容）
画布初始情况下， 是以左上角坐标为原点的第一象限。如果参数为负实数， 相当于以x 或 y轴作为对称轴镜像反转
（例如， 使用translate(0,canvas.height); scale(1,-1); 
以y轴作为对称轴镜像反转， 就可得到著名的笛卡尔坐标系，左下角为原点）。
默认情况下，canvas 的 1 个单位为 1 个像素。举例说，如果我们设置缩放因子是 0.5，1 个单位就变成对应 0.5 个像素，
这样绘制出来的形状就会是原先的一半。同理，设置为 2.0 时，1 个单位就对应变成了 2 像素，绘制的结果就是图形放大了 2 倍
（在对应的单位情况下，一个单位对应的像素变了，例：缩放前，1单位对应1像素，0.5的话，缩放后，1单位对应0.5像素（原来的1像素*0.5），
                                              缩放前，1单位对应2像素，0.5的话，缩放后，1单位对应1像素）
画图的方法的长度单位并不是1个像素点
例如 fillRect(0,0,100,100)，表示长为100 * canvas默认单位长度，宽为100 * canvas默认单位长度。（canvas默认单位长度为1px）

最后一个方法允许对变形矩阵直接修改：transform(m11, m12, m21, m22, dx, dy)（每一个变形对应一个变形矩阵）
m11 m21 dx
m12 m22 dy
  0  	0 	1
这个方法是将当前的变形矩阵乘上一个基于自身参数的矩阵
m11：水平方向的缩放
m12：水平方向的倾斜偏移
m21：竖直方向的倾斜偏移
m22：竖直方向的缩放
dx：水平方向的移动
dy：竖直方向的移动

setTransform(m11, m12, m21, m22, dx, dy)
这个方法会将当前的变形矩阵重置为单位矩阵，然后用相同的参数调用 transform 方法。从根本上来说，该方法是取消了当前变形,然后设置为指定的变形,一步完成

resetTransform()
重置当前变形为单位矩阵，它和调用以下语句是一样的：ctx.setTransform(1, 0, 0, 1, 0, 0);

globalCompositeOperation = type
这个属性设定了在画新图形时采用的遮盖策略，其值是一个标识12种遮盖方式的字符串：
source-over 这是默认设置，并在现有画布上下文之上绘制新图形
source-in 新图形只在新图形和目标画布重叠的地方绘制。其他的都是透明的
source-out 在不与现有画布内容重叠的地方绘制新图形
source-atop 新图形只在与现有画布内容重叠的地方绘制
destination-over 在现有的画布内容后面绘制新的图形
destination-in 现有的画布内容保持在新图形和现有画布内容重叠的位置。其他的都是透明的
destination-out 现有内容保持在新图形不重叠的地方
destination-atop 现有的画布只保留与新图形重叠的部分，新的图形是在画布内容后面绘制的
lighter 两个重叠图形的颜色是通过颜色值相加来确定的
copy 只显示新图形
xor 图像中，那些重叠和正常绘制之外的其他地方是透明的
multiply 将顶层像素与底层相应像素相乘，结果是一幅更黑暗的图片
screen 像素被倒转，相乘，再倒转，结果是一幅更明亮的图片
overlay multiply和screen的结合，原本暗的地方更暗，原本亮的地方更亮
darken 保留两个图层中最暗的像素
lighten 保留两个图层中最亮的像素
color-dodge 将底层除以顶层的反置
color-burn 将反置的底层除以顶层，然后将结果反过来
hard-light 屏幕相乘（A combination of multiply and screen）类似于叠加，但上下图层互换了
soft-light 用顶层减去底层或者相反来得到一个正值
difference 一个柔和版本的强光（hard-light）。纯黑或纯白不会导致纯黑或纯白
exclusion 和difference相似，但对比度较低
hue 保留了底层的亮度（luma）和色度（chroma），同时采用了顶层的色调（hue）
saturation 保留底层的亮度（luma）和色调（hue），同时采用顶层的色度（chroma）
color 保留了底层的亮度（luma），同时采用了顶层的色调(hue)和色度(chroma)
luminosity 保持底层的色调（hue）和色度（chroma），同时采用顶层的亮度（luma）

裁切路径和普通的 canvas 图形差不多，不同的是它的作用是遮罩，用来隐藏不需要的部分。
如右图所示。红边五角星就是裁切路径，所有在路径以外的部分都不会在 canvas 上绘制出来
和上面介绍的 globalCompositeOperation 属性作一比较，它可以实现与 source-in 和 source-atop差不多的效果。
最重要的区别是裁切路径不会在 canvas 上绘制东西，而且它永远不受新图形的影响。这些特性使得它在特定区域里绘制图形时相当好用

clip() 将当前正在构建的路径转换为当前的裁剪路径，默认情况下，canvas 有一个与它自身一样大的裁切路径（也就是没有裁切效果）

动画的基本步骤
你可以通过以下的步骤来画出一帧:
清空 canvas
保存 canvas 状态
绘制动画图形（animated shapes）
恢复 canvas 状态

requestAnimationFrame(callback)告诉浏览器你希望执行一个动画，并在重绘之前，请求浏览器执行一个特定的函数来更新动画
这个方法提供了更加平缓并更加有效率的方式来执行动画，当系统准备好了重绘条件的时候，才调用绘制动画帧。一般每秒钟回调函数执行60次，也有可能会被降低。
window.requestAnimationFrame()该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行
若你想在浏览器下次重绘之前继续更新下一帧动画，那么回调函数自身必须再次调用window.requestAnimationFrame()
回调函数会被传入DOMHighResTimeStamp参数，DOMHighResTimeStamp指示当前被 requestAnimationFrame() 排序的回调函数被触发的时间。
在同一个帧中的多个回调函数，它们每一个都会接受到一个相同的时间戳，即使在计算上一个回调函数的工作负载期间已经消耗了一些时间
它表示requestAnimationFrame() 开始去执行回调函数的时刻
返回值
一个 long 整数，请求 ID ，是回调列表中唯一的标识。是个非零值，没别的意义。你可以传这个值给 window.cancelAnimationFrame() 以取消回调函数
raf = window.requestAnimationFrame(draw);
window.cancelAnimationFrame(raf);（取消现在的动画）

如果您肯定会建议将DOM用于UI，那么您确实应该使用CSS过渡和/或CSS动画，而不是JavaScript驱动的动画
在为<canvas>内容设置动画时，或者当DOM动画绝对必须与画布内容动画同步时，请务必使用window.requestAnimationFrame，而不要使用window.setTimeout

为了节省电池寿命，最好仅在有事情发生时才进行绘制，这意味着要requestAnimationFrame响应游戏中发生的事件调用（或刷新函数，依次调用该函数）
不幸的是，这很容易导致每帧多次绘制图形，一种简单的方法是声明自己的刷新函数，该函数在调用时设置标志requestAnimationFrame
执行回调时，您可以取消设置该标志，以便对该函数的调用将再次请求一个新的帧
function redraw() {
  drawPending = false;
  // Do drawing ...
}

var drawPending = false;
function requestRedraw() {
  if (!drawPending) {
    drawPending = true;
    requestAnimationFrame(redraw);
  }
}遵循这种模式（或类似的模式）意味着，无论您调用requestRedraw多少次，绘制函数每帧只会被调用一次
使用requestAnimationFrame（通常）进行绘图时，可能会阻止浏览器更新其他内容。尽量不要在动画功能之外进行不必要的工作

ImageData对象中存储着canvas对象真实的像素数据，它包含以下几个只读属性：
width图片宽度，单位是像素
height图片高度，单位是像素
data Uint8ClampedArray类型的一维数组，包含着RGBA格式的整型数据，范围在0至255之间（包括255）
每个像素用4个1bytes值(按照红，绿，蓝和透明值的顺序; 这就是"RGBA"格式) 来代表
三个参数，第一个 是Uint8ClampedArray的实例，第二个和第三个表示的是width和height，必须保证Uint8ClampedArray的length = 4*width*height才不会报错，
如果第一个参数Uint8ClampedArray没有的话，自动按照width和height的大小，以0填充整个像素矩阵

var myImageData = ctx.createImageData(width, height);
上面代码创建了一个新的具体特定尺寸的ImageData对象。所有像素被预设为透明黑。
你也可以创建一个被anotherImageData对象指定的相同像素的ImageData对象。这个新的对象像素全部被预设为透明黑。这个并非复制了图片数据。
var myImageData = ctx.createImageData(anotherImageData);

为了获得一个包含画布场景像素数据的ImageData对像，你可以用getImageData()方法：
var myImageData = ctx.getImageData(left, top, width, height);
这个方法会返回一个ImageData对象，它代表了画布区域的对象数据，此画布的四个角落分别表示为(left, top), (left + width, top), (left, top + height)
以及(left + width, top + height)四个点。这些坐标点被设定为画布坐标空间元素
注：任何在画布以外的元素都会被返回成一个透明黑的ImageData对像

function pick(event) {
  var x = event.layerX;
  var y = event.layerY;
  var pixel = ctx.getImageData(x, y, 1, 1);
  var data = pixel.data;
  var rgba = 'rgba(' + data[0] + ',' + data[1] +
             ',' + data[2] + ',' + (data[3] / 255) + ')';
  color.style.background =  rgba;
  color.textContent = rgba;
}

用putImageData()方法去对场景进行像素数据的写入
ctx.putImageData(myImageData, dx, dy);
dx和dy参数表示你希望在场景内左上角绘制的像素数据所得到的设备坐标
例如，为了在场景内左上角绘制myImageData代表的图片，你可以写如下的代码：
ctx.putImageData(myImageData, 0, 0);

toDataURL()方法，此方法在保存图片的时候非常有用，它返回一个包含被类型参数规定的图像表现格式的数据链接，返回的图片分辨率是96dpi。
canvas.toDataURL('image/png')默认设定。创建一个PNG图片。
canvas.toDataURL('image/jpeg', quality) 创建一个JPG图片。你可以有选择地提供从0到1的品质量，1表示最好品质，0基本不被辨析但有比较小的文件大小

ctx.imageSmoothingEnabled = value设置图片是否平滑的属性，true表示图片平滑（默认值），false表示图片不平滑

Blob 对象表示一个不可变、原始数据的类文件对象

Accessible Rich Internet Applications (ARIA) 
定义了让Web内容和Web应用更容易被有身体缺陷的人获取的办法。你可以用ARIA属性来描述canvas元素的行为和存在目的
点击区域（hit region）
判断鼠标坐标是否在canvas上一个特定区域里一直是个有待解决的问题。hit region API让你可以在canvas上定义一个区域，
这让无障碍工具获取canvas上的交互内容成为可能
焦点圈:当用键盘控制时，焦点圈是一个能帮我们在页面上快速导航的标记

什么是SVG？
SVG 指可伸缩矢量图形 (Scalable Vector Graphics)
SVG 用于定义用于网络的基于矢量的图形
SVG 使用 XML 格式定义图形
SVG 图像在放大或改变尺寸的情况下其图形质量不会有损失
SVG 是万维网联盟的标准

SVG 的优势
与其他图像格式相比（比如 JPEG 和 GIF），使用 SVG 的优势在于：
SVG 图像可通过文本编辑器来创建和修改
SVG 图像可被搜索、索引、脚本化或压缩
SVG 是可伸缩的
SVG 图像可在任何的分辨率下被高质量地打印
SVG 可在图像质量不下降的情况下被放大
SVG 图像中的文本是可选的，同时也是可搜索的（很适合制作地图）

SVG 是使用 XML 来描述二维图形和绘图程序的语言
SVG 文件必须使用 .svg 后缀来保存
SVG 代码以 <svg> 元素开始，包括开启标签 <svg> 和关闭标签 </svg> 。这是根元素。width 和 height 属性可设置此 SVG 文档的宽度和高度
version 属性可定义所使用的 SVG 版本，xmlns 属性可定义 SVG 命名空间。
<svg width="100%" height="100%" version="1.1"
xmlns="http://www.w3.org/2000/svg">

SVG 文件可通过以下标签嵌入 HTML 文档：<embed>、<object> 或者 <iframe>
<embed src="rect.svg" width="300" height="100" type="image/svg+xml" pluginspage="http://www.adobe.com/svg/viewer/install/" />
注释：pluginspage 属性指向下载插件的 URL
<object> 标签是 HTML 4 的标准标签，被所有较新的浏览器支持。它的缺点是不允许使用脚本。
注释：假如您安装了最新版本的 Adobe SVG Viewer，那么当使用 <object> 标签时 SVG 文件无法工作（至少不能在 IE 中工作）！
<object data="rect.svg" width="300" height="100" type="image/svg+xml" codebase="http://www.adobe.com/svg/viewer/install/" />
注释：codebase 属性指向下载插件的 URL。

例：<?xml version="1.0" standalone="no"?>

<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" 
"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">

<svg width="100%" height="100%" version="1.1"
xmlns="http://www.w3.org/2000/svg">定义了一个100*100px的SVG画布

<rect x="20" y="20" rx="20" ry="20" width="250"
height="100" style="fill:red;stroke:black;
stroke-width:5;opacity:0.5"/>
（rx 和 ry 属性可使矩形产生圆角)
rx圆角的x方位的半径
ry圆角的y方位的半径
</svg>

<ellipse> 标签可用来创建椭圆 
cx 属性定义圆点的 x 坐标
cy 属性定义圆点的 y 坐标
rx 属性定义水平半径
ry 属性定义垂直半径

<line> 标签用来创建线条
x1 属性在 x 轴定义线条的开始
y1 属性在 y 轴定义线条的开始
x2 属性在 x 轴定义线条的结束
y2 属性在 y 轴定义线条的结束

<polygon> 标签用来创建含有不少于三个边的图形
points 属性定义多边形每个角的 x 和 y 坐标 
例：<polygon points="220,100 300,210 170,250" style="fill:#cccccc; stroke:#000000;stroke-width:1"/>
polygon的路径在最后一个点处自动回到第一个点

<polyline> 标签用来创建仅包含直线的形状
例：<polyline points="0,0 0,20 20,20 20,40 40,40 40,60" style="fill:white;stroke:red;stroke-width:2"/>

<path> 标签用来定义路径（均为闭合的）
下面的命令可用于路径数据：
M = moveto
L = lineto
H = horizontal lineto H，绘制水平线(H x (or h dx右为正，左为负))
V = vertical lineto   V，绘制垂直线(V y (or v dy下为正，上为负))
C = curveto 三次贝塞尔曲线，控制点描述的是曲线起始点的斜率和曲线结束点的斜率，曲线上各个点的斜率，是从起点斜率到终点斜率的渐变过程
S = smooth curveto
Q = quadratic Belzier curve二次贝塞尔曲线Q只需要一个控制点，用来确定起点和终点的曲线斜率
T = smooth quadratic Belzier curveto
A = elliptical Arc
Z = closepath(不区分大小写）
注释：以上所有命令均允许小写字母。大写表示绝对定位，小写表示相对定位（例如：从上一个点开始，向上移动10px，向左移动7px）
例：<path d="M250 150 L150 350 L350 350 Z" />（m dx dy)
属性d采用的是用户坐标系统，所以不需标明单位
三次贝塞尔曲线有一个S命令，二次贝塞尔曲线有一个T命令，可以通过更简短的参数，延长贝塞尔曲线
S:S x2 y2, x y (or s dx2 dy2, dx dy)(第二个控制点以及结束点）
S命令可以用来创建与前面一样的贝塞尔曲线，但是，如果S命令跟在一个C或S命令后面，
则它的第一个控制点会被假设成前一个命令曲线的第二个控制点的中心对称点（以前一个S或C的结束点作中心对称）
如果S命令单独使用，前面没有C或S命令，那当前点将作为第一个控制点
T x y (or t dx dy)（结束点）
T命令前面必须是一个Q命令，或者是另一个T命令，和上述的S命令的对称方式相同。如果T单独使用，那么控制点就会被认为和终点是同一个点，所以画出来的将是一条直线
弧形命令A
 A rx ry x-axis-rotation large-arc-flag sweep-flag x y
 a rx ry x-axis-rotation large-arc-flag sweep-flag dx dy
 rx,ry x,y轴半径
 x,y 终点
 x-axis-rotation（x轴旋转角度） 
 large-arc-flag（角度大小），large-arc-flag决定弧线是大于还是小于180度，0表示小角度弧，1表示大角度弧
 sweep-flag（弧线方向），sweep-flag表示弧线的方向，0表示从起点到终点沿逆时针画弧，1表示从起点到终点沿顺时针画弧
 
通过指定stroke-dasharray属性，将虚线类型应用在描边上
stroke-dasharray属性的参数，是一组用逗号分割的数字组成的数列，数字必须用逗号分割（空格会被忽略）
每一组数字，第一个用来表示填色区域的长度，第二个用来表示非填色区域的长度（第一个是填色的）
第一个例子指定了3个数字，这种情况下，数字会循环两次，形成一个偶数的虚线模式（奇数个循环两次变偶数个）。所以该路径首先渲染5个填色单位，10个空白单位，
5个填色单位，然后回头以这3个数字做一次循环，但是这次是创建5个空白单位，10个填色单位，5个空白单位。通过这两次循环得到偶数模式，并将这个偶数模式不断重复

SVG规范将属性区分成properties和其他attributes，前者是可以用CSS设置的，后者不能
在svg里<style>则放在<defs>标签里。<defs>表示定义，这里面可以定义一些不会在SVG图形中出现、但是可以被其他元素使用的元素
<?xml version="1.0" standalone="no"?>
<svg width="200" height="200" xmlns="http://www.w3.org/2000/svg" version="1.1">
  <defs>
    <style type="text/css"><![CDATA[
       #MyRect {
         stroke: black;
         fill: red;
       }
    ]]></style>
  </defs>
  <rect x="10" height="180" y="10" width="180" id="MyRect"/>
</svg>
定义一个外部的样式表，但是要符合normal XML-stylesheet syntax的CSS规则<?xml-stylesheet type="text/css" href="style.css"?>

必须在 <defs> 标签中定义 SVG 滤镜
例：
<defs>
<filter id="Gaussian_Blur">
<feGaussianBlur in="SourceGraphic" stdDeviation="3" />
</filter>
</defs>

<ellipse cx="200" cy="150" rx="70" ry="40"
style="fill:#ff0000;stroke:#000000;
stroke-width:2;filter:url(#Gaussian_Blur)"/>

SVG 渐变必须在 <defs> 标签中进行定义
<linearGradient> 可用来定义 SVG 的线性渐变
当 y1 和 y2 相等，而 x1 和 x2 不同时，可创建水平渐变
当 x1 和 x2 相等，而 y1 和 y2 不同时，可创建垂直渐变
当 x1 和 x2 不同，且 y1 和 y2 不同时，可创建角形渐变
例：
<defs>
<linearGradient id="orange_red" x1="0%" y1="0%" x2="100%" y2="0%">
<stop offset="0%" style="stop-color:rgb(255,255,0);
stop-opacity:1"/>
<stop offset="100%" style="stop-color:rgb(255,0,0);
stop-opacity:1"/>
</linearGradient>
</defs>

<ellipse cx="200" cy="190" rx="85" ry="55"
style="fill:url(#orange_red)"/>
线性渐变内部有几个<stop>（中值）结点，这些结点通过指定位置的offset（偏移）属性和stop-color（颜色中值）属性来说明在渐变的特定位置上应该是什么颜色
偏移量应该始终从0%开始（或者0也可以，百分号可以扔掉），到100%（或1）结束。如果stop设置的位置有重合，将使用XML树中较晚设置的值
渐变色默认是水平方向的
可以在渐变上使用xlink:href属性。
如果使用了该属性时，一个渐变的属性和颜色中值（stop）可以被另一个渐变包含引用。在下例中，你就不需要再Grandient2中重新创建全部的颜色中值（stop）
<linearGradient id="Gradient1">
   <stop id="stop1" offset="0%"/>
   <stop id="stop2" offset="50%"/>
   <stop id="stop3" offset="100%"/>
 </linearGradient>
 <linearGradient id="Gradient2" x1="0" x2="0" y1="0" y2="1" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#Gradient1"/>
    
<defs>
<radialGradient id="grey_blue" cx="50%" cy="50%" r="50%"
fx="50%" fy="50%">
<stop offset="0%" style="stop-color:rgb(200,200,200);
stop-opacity:0"/>
<stop offset="100%" style="stop-color:rgb(0,0,255);
stop-opacity:1"/>
</radialGradient>
</defs>

<ellipse cx="230" cy="200" rx="110" ry="100"
style="fill:url(#grey_blue)"/>
cx、cy 和 r 属性定义了渐变结束所围绕的圆环，它需要一个中心点
焦点，由fx和fy属性定义。第一个点描述了渐变边缘位置，焦点则描述了渐变的中心
如果焦点移到圆圈的外面，渐变将不能正确呈现，所以该点会被假定在圆圈范围内。如果没有给出焦点，将认为该点与中心点的位置一致
spreadMethod属性，该属性控制了当渐变到达终点的行为，但是此时该对象尚未被填充颜色。这个属性可以有三个值：pad、reflect或repeat
pad当渐变到达终点时，最终的偏移颜色被用于填充对象剩下的空间。
reflect会让渐变一直持续下去，不过它的效果是与渐变本身是相反的，以100%偏移位置的颜色开始，逐渐偏移到0%位置的颜色，然后再回到100%偏移位置的颜色
repeat也会让渐变继续，但是它不会像reflect那样反向渐变，而是跳回到最初的颜色然后继续渐变
两种渐变都有一个叫做 gradientUnits（渐变单元）的属性，它描述了用来描述渐变的大小和方向的单元系统。该属性有两个值：userSpaceOnUse 、objectBoundingBox。
默认值为objectBoundingBox，我们目前看到的效果都是在这种系统下的，它大体上定义了对象的渐变大小范围，所以你只要指定从0到1的坐标值，
渐变就会自动的缩放到对象相同大小。userSpaceOnUse使用绝对单元，所以你必须知道对象的位置，并将渐变放在同样地位置上

<text x="15" y="30" fill="white" font-family="sans-serif" font-size="12pt">Pad</text>

<pattern>需要放在SVG文档的<defs>内部
patternUnits属性：同 gradientUnits属性（在objectBoundingBox下，width和height设置为0.5为对象的一半，以此类推）
patternContentUnits属性：描述了pattern元素基于基本形状使用的单元系统，这个属性默认值为userSpaceOnUse
userSpaceOnUse:有确认的大小(不变)并且重复他们自己，与对象形状独立开来，为了美观需要自己调整位置:x和y 或者大小
这意味着除非你至少指定其中一个属性值（patternContentUnits或patternUnits），
否则在pattern中绘制的形状（patternUnits）将与pattern元素（patternContentUnits）使用的坐标系不同
因为pattern内容与pattern本身处于相同的单元系统中，所以我们不用偏移边框以使pattern在正确的位置上开始，并且即使对象变大，
pattern也会自动的缩放以保证pattern内部的对象数目和重复不变。
这与userSpaceOnUse系统不同，userSpaceOnUse系统中如果对象改变大小，pattern本身会保持不变，只是重复更多次去填满边框
<pattern id="Pattern" width=".25" height=".25" patternContentUnits="objectBoundingBox">(pattern以及pattern里的内容百分比均为相对于对象来说）
   <rect x="0" y="0" width=".25" height=".25" fill="skyblue"/>
   <rect x="0" y="0" width=".125" height=".125" fill="url(#Gradient2)"/>
   <circle cx=".125" cy=".125" r=".1" fill="url(#Gradient1)" fill-opacity="0.5"/>
 </pattern>
如果你已经知道了如何创建基本SVG文件，下一步就是把它们上传到web服务器，但是在这阶段有一些陷阱。对于普通SVG文件，服务器应该会发送下面的HTTP头：
Content-Type: image/svg+xml
Vary: Accept-Encoding
对于gzip压缩的SVG文件，服务器应该会发送下面的HTTP头：
Content-Type: image/svg+xml
Content-Encoding: gzip
Vary: Accept-Encoding

基本上，在 SVG 文档中的1个像素对应输出设备（比如显示屏）上的1个像素。但是这种情况是可以改变的，否则 SVG 的名字里也不至于会有“Scalable”（可缩放）这个词。
如同CSS可以定义字体的绝对大小和相对大小，SVG也可以定义绝对大小（比如使用“pt”或“cm”标识维度）同时SVG也能使用相对大小，
只需给出数字，不标明单位，输出时就会采用用户的单位
在没有进一步规范说明的情况下，1个用户单位等同于1个屏幕单位。要明确改变这种设定，SVG里有多种方法(svg跟用户，用户与屏幕单位有规定）
<svg width="200" height="200" viewBox="0 0 100 100">
这里定义的画布尺寸是200*200px。但是，viewBox属性定义了画布上可以显示的区域：从(0,0)点开始，100宽*100高的区域。
这个100*100的区域，会放到200*200的画布上显示。于是就形成了放大两倍的效果
